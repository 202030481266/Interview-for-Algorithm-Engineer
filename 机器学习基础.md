# <center>----【机器学习基础】----</center>

## 【一】什么是模型的偏差和方差？
  
误差（Error）= 偏差（Bias） + 方差（Variance） + 噪声（Noise），一般地，我们把机器学习模型的预测输出与样本的真实label之间的差异称为误差，其反应的是整个模型的准确度。

噪声（Noise）：描述了在当前任务上任何机器学习算法所能达到的<font color=DeepSkyBlue>期望泛化误差的下界</font>，即刻画了当前任务本质的难度。

偏差（Bias）：衡量了模型拟合训练数据的能力，偏差反应的是所有采样得到的大小相同的训练集训练出的所有模型的输出平均值和真实label之间的偏差，即模型本身的精确度。

偏差通常是由于我们对机器学习算法做了错误的假设所导致的，比如真实数据分布映射的是某个二次函数，但我们假设模型是一次函数。

<font color=DeepSkyBlue>偏差（Bias）越小，拟合能力却强（可能产生过拟合）；反之，拟合能力越弱（可能产生欠拟合）</font>。偏差越大，越偏离真实数据。

方差描述的是预测值的变化范围，离散程度，也就是离期望值的距离。<font color=DeepSkyBlue>方差越大，数据的分布越分散，模型的稳定程度越差</font>。

方差也反应了模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。<font color=DeepSkyBlue>由方差带来的误差通常体现在测试误差相对于训练误差的增量上</font>。

方差通常是由于模型的复杂度相对于训练样本数过高导致的。<font color=DeepSkyBlue>方差越小，模型的泛化能力越高；反之，模型的泛化能力越低</font>。

如果模型在训练集上拟合效果比较优秀，但是在测试集上拟合效果比较差，则表示方差较大，说明模型的稳定程度较差，出现这种现象可能是由于模型对训练集过拟合造成的。

接下来我们用下面的射击的例子进一步解释这二者的区别。假设一次射击就是机器学习模型对一个样本进行预测。射中靶心位置代表预测准确，偏离靶心越远代表预测误差越大，其中左上角是最好的结果。

![](https://files.mdnice.com/user/33499/e6a5dec3-92c5-44c9-a37c-9ea882b71c7c.png)

## 【二】数据类别不平衡怎么处理？
  
1. 数据增强。

2. 对少数类别数据做过采样，多数类别数据做欠采样。

3. 损失函数的权重均衡。（不同类别的loss权重不一样，最佳参数需要手动调节）

4. 采集更多少数类别的数据。

5. 转化问题定义，将问题转化为异常点检测或变化趋势检测问题。 异常点检测即是对那些罕见事件进行识别，变化趋势检测区别于异常点检测，其通过检测不寻常的变化趋势来进行识别。

6. 使用新的评价指标。

7. 阈值调整，将原本默认为0.5的阈值调整到：较少类别/（较少类别+较多类别）。

## 【三】什么是过拟合，解决过拟合的方法有哪些？
  
<font color=DeepSkyBlue>过拟合</font>：模型在训练集上拟合的很好，但是模型连噪声数据的特征都学习了，丧失了对测试集的泛化能力。

<font color=DeepSkyBlue>解决过拟合的方法</font>：

1. 重新清洗数据，数据不纯会导致过拟合，此类情况需要重新清洗数据或重新选择数据。
  
2. 增加训练样本数量。使用更多的训练数据是解决过拟合最有效的手段。我们可以通过一定的规则来扩充训练数据，比如在图像分类问题上，可以通过图像的平移、旋转、缩放、加噪声等方式扩充数据;也可以用GAN网络来合成大量的新训练数据。
3. 降低模型复杂程度。适当降低模型复杂度可以避免模型拟合过多的噪声数据。在神经网络中减少网络层数、神经元个数等。
4. 加入正则化方法，增大正则项系数。给模型的参数加上一定的正则约束，比如将权值的大小加入到损失函数中。
5. 采用dropout方法，dropout方法就是在训练的时候让神经元以一定的概率失活。
6. 提前截断（early stopping），减少迭代次数。
7. 增大学习率。
8. 集成学习方法。集成学习是把多个模型集成在一起，来降低单一模型的过拟合风险，如Bagging方法。

## 【四】什么是欠拟合，解决欠拟合的方法有哪些？
  
<font color=DeepSkyBlue>欠拟合</font>：模型在训练集和测试集上效果均不好，其根本原因是模型没有学习好数据集的特征。

<font color=DeepSkyBlue>解决欠拟合的方法</font>：

1. 可以增加模型复杂度。对于神经网络可以增加网络层数或者神经元数量。

2. 减小正则化系数。正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要有针对性地减小正则化系数。

3. Boosting。

## 【五】常用的距离度量方法

1. 欧式距离

2. 闵可夫斯基距离

3. 马氏距离

4. 互信息

5. 余弦距离

6. 皮尔逊相关系数

7. Jaccard相关系数

8. 曼哈顿距离
  
![](https://files.mdnice.com/user/33499/d17199ff-84e7-49e1-bbf5-19a2b12e6686.png)

## 【六】正则化的本质以及常用正则化手段？
  
正则化是机器学习的核心主题之一。<font color=DeepSkyBlue>正则化本质是对某一问题加以先验的限制或约束以达到某种特定目的的一种操作</font>。在机器学习中我们通过使用正则化方法，防止其过拟合，降低其泛化误差。

常用的正则化手段：

1. 数据增强
  
2. 使用L范数约束
3. dropout
4. early stopping
5. 对抗训练

## 【七】L范数的作用？
  
L范数主要起到了正则化（<font color=DeepSkyBlue>即用一些先验知识约束或者限制某一抽象问题</font>）的作用，而正则化主要是防止模型过拟合。

范数主要用来表征高维空间中的距离，故在一些生成任务中也直接用L范数来度量生成图像与原图像之间的差别。

下面列出深度学习中的范数：
  
![](https://files.mdnice.com/user/33499/bca9e394-0548-4882-8e7f-47607bebbba7.png)

![](https://files.mdnice.com/user/33499/5c98ba3a-d4d1-4078-9ee9-5146990e3363.png)


## 【八】Dropout的作用？

Dropout是在训练过程中以一定的概率使神经元失活，也就是输出等于0。从而提高模型的泛化能力，减少过拟合。
  
![使用Dropout](https://files.mdnice.com/user/33499/5f3b5d37-facd-4817-a765-990e6833b4a7.png)

我们可以从<font color=DeepSkyBlue>两个方面去直观地理解Dropout的正则化效果</font>：1）在Dropout每一轮训练过程中随机丢失神经元的操作相当于多个模型进行取平均，因此用于预测时具有vote的效果。2）减少神经元之间复杂的共适应性。当隐藏层神经元被随机删除之后，使得全连接网络具有了一定的稀疏化，从而有效地减轻了不同特征的协同效应。也就是说，有些特征可能会依赖于固定关系的隐含节点的共同作用，而通过Dropout的话，就有效地避免了某些特征在其他特征存在下才有效果的情况，增加了神经网络的鲁棒性。

<font color=DeepSkyBlue>Dropout在训练和测试时的区别</font>：Dropout只在训练时产生作用，是为了减少神经元对部分上层神经元的依赖，类似将多个不同网络结构的模型集成起来，减少过拟合风险。而在测试时，应该用整个训练好的模型，因此不需要Dropout。


## 【九】Softmax的定义和作用
  
在二分类问题中，我们可以使用sigmoid函数将输出映射到【0，1】区间中，从而得到单个类别的概率。当我们将问题推广到多分类问题时，可以使用Softmax函数，对输出的值映射为概率值。
  
![](https://files.mdnice.com/user/33499/ba15fa57-2ef3-4a47-9536-4bc277428f01.png)

其定义为：

![](https://files.mdnice.com/user/33499/526a9221-7dae-4f45-99ae-7d9f77dc3aa3.png)

其中a代表了模型的输出。

## 【十】交叉熵定义和作用

交叉熵（cross entropy）常用于深度学习中的分类任务，其可以表示预测值与ground truth之间的差距。

交叉熵是信息论中的概念。其定义为：
  
![](https://files.mdnice.com/user/33499/7c811f76-ef47-42b9-93b2-25517e7463ed.png)

$P$代表$gt$的概率分布，$q$代表预测值的概率分布。交叉熵从相对熵（KL散度）演变而来，$log$代表了信息量，$q$越大说明可能性越大，其信息量越少；反之则信息量越大。通过不断的训练优化，逐步减小交叉熵损失函数的值来达到缩小$p$和$q$距离的目的。

## 【十一】训练集/验证集/测试集划分
  
机器学习的直接目的是希望模型在真实场景的数据上有很好的预测效果，泛化误差越低越好。

如何去跟踪泛化误差呢？这时就需要验证集和测试集了。

我们可以使用训练集的数据来训练模型，然后用测试集上的误差推测最终模型在应对现实场景中的泛化误差。有了测试集，我们可以在本地验证模型的最终的近似效果。

与此同时，我们在模型训练过程中要实时监控模型的指标情况，从而进行模型参数优选操作。验证集就用于模型训练过程中的指标评估。

一般来说，如果当数据量不是很大的情况（万级别以下）可以将训练集、验证集和测试集划分为<font color=DeepSkyBlue>6：2：2</font>；如果是万级别甚至十万级别的数据量，可以将训练集、验证集和测试集比例调整为<font color=DeepSkyBlue>98：1：1</font>。

（注：在数据集划分时要主要类别的平衡）

## 【十二】如何找到让F1最高的分类阈值？
  
首先，这个问题只存在于二分类问题中，对于多分类问题，只需要概率最高的那个预测标签作为输出结果即可。

F1值是综合了精准率和召回率两个指标对模型进行评价：
  
![](https://files.mdnice.com/user/33499/9ed8d70a-11fe-4e11-9bf1-6f7666965316.png)

一般设0.5作为二分类的默认阈值，但一般不是最优阈值。想要精准率高，一般使用高阈值，而想要召回率高，一般使用低阈值。在这种情况下，我们通常可以通过P-R曲线去寻找最优的阈值点或者阈值范围。

## 【十三】机器学习有哪些种类？

机器学习中通常根据数据是否有标签可以分为监督学习(supervised learning)、非监督学习(unsupervised learning)，半监督学习(semi-supervised learning)以及弱监督学习(weakly supervised learning)。

**监督学习**

机器学习模型在训练过程中的所有数据都有标签，就是监督学习的逻辑。

监督学习是最常见的学习种类，常见场景为分类和回归问题。

深度学习模型大都数都遵从监督学习的流程，并且支持向量机(Support Vector Machine, SVM)，朴素贝叶斯(Naive Bayes)，逻辑回归(Logistic Regression)，K近邻(K-Nearest Neighborhood, KNN)，决策树(Decision Tree)，随机森林(Random Forest)，AdaBoost以及线性判别分析(Linear Discriminant Analysis, LDA)等也属于监督学习算法的范畴。

**非监督学习**

非监督学习与监督学习完全相反，机器学习模型在训练过程中的所有数据都是没有标签的，主要学习数据本身的一些特性。

比如想象一个人从来没有见过猫和狗，如果给他看了大量的猫和狗，虽然他还是没有猫和狗的概念，但是他是能够观察出每个物种的共性和两个物种间的区别的，并对这个两种动物予以区分。

**半监督学习**

半监督学习的逻辑是机器学习模型在训练过程中，部分数据有标签，与此同时另外一部分数据没有标签，并把这两种数据都利用起来用于训练。

**弱监督学习** 

弱监督学习的逻辑是机器学习模型在训练过程中使用的数据的标签存在不可靠的情况。这里的不可靠可以是标注不正确，多重标记，标记不充分，局部标记，包含噪声等情况。一个直观的例子是相对于分割的标签来说，分类的标签就是弱标签。

## 【十四】L1正则为什么比L2正则更容易产生稀疏解?

我们首先可以设目标函数为$L$，目标函数中的权值参数为$w$，那么目标函数和权值参数的关系如下所示：

![](https://img-blog.csdnimg.cn/20200817112906402.png)

如上图所示，最优的$w$在绿色的点处，而且$w$非零。

我们首先可以使用L2正则进行优化，新的目标函数：$L + CW^{2}$，示意图如下蓝线所示：

![](https://img-blog.csdnimg.cn/20200817113043873.png)

我们可以看到，最优的$w$出现在黄点处，$w$的绝对值减小了，更靠近横坐标轴，但是依然是非零的。

<font color=DeepSkyBlue>为什么是非零的呢？</font>

我们可以对L2正则下的目标函数求导：

![](https://files.mdnice.com/user/33499/6fff569d-11fa-4c0d-93e7-604f6aed387e.png)

我们发现，权重$w$每次乘上的是小于1的倍数进行收敛，而且其导数在$w=0$时没有办法做到左右两边导数异号，所以L2正则使得整个训练过程稳定平滑，但是没有产生稀疏性。

接下来我们使用L1正则，新的目标函数：$L + C|w|$，示意图如下粉线所示：

![](https://img-blog.csdnimg.cn/20200817115050210.png)

这里最优的$w$就变成了0。因为保证使用L1正则后$x=0$处左右两个导数异号，就能满足极小值点形成的条件。

我们来看看这次目标函数求导的式子：

![](https://img-blog.csdnimg.cn/20200817115308997.png)

可以看出L1正则的惩罚很大，$w$每次都是减去一个常数的线性收敛，所以L1比L2更容易收敛到比较小的值，而如果$C > |f^{'}(0)|$，就能保证$w = 0$处取得极小值。

上面只是一个权值参数$w$。在深层网路中，L1会使得大量的$w$最优值变成0，从而使得整个模型有了稀疏性。

## 【十五】格拉姆矩阵的相关概念？

n维欧式空间中任意k个向量之间两两的内积所组成的矩阵，称为这k个向量的格拉姆矩阵(Gram matrix)，这是一个对称矩阵。 

![](https://files.mdnice.com/user/33499/a850fa8d-7ae5-415d-89ad-230836e01a49.png)

![](https://files.mdnice.com/user/33499/08889876-98b7-4a2f-ad50-7ea4eb7128a7.png)

其中对角线元素提供了k个不同特征图（a1，a2 ... ，ak）各自的信息，其余元素提供了不同特征图之间的相关信息。既能体现出有哪些特征，又能体现出不同特征间的紧密程度。图像风格迁移领域将其定义为风格特征。

格拉姆矩阵在风格迁移中有广泛的应用，深度学习中经典的风格迁移流程是：

1. 准备基线图像和风格图像。

2. 使用特征提取器分别提取基线图像和风格图像的feature map。

3. 分别计算两个图像的feature map的格拉姆矩阵，以两个图像的格拉姆矩阵的差异最小化为优化目标，不断调整基线图像，使风格不断接近目标风格图像。

## 【十六】感知损失的相关概念?

感知损失在图像生成领域中比较常用。其核心是将gt图片卷积得到的高层feature与生成图片卷积得到的高层feature进行回归，从而约束生成图像的高层特征（内容和全局结构）。

![经典感知损失结构](https://files.mdnice.com/user/33499/2c510820-c674-4e92-bd10-a742f1d1218f.png)

上面的公式中，划线部分代表了高层特征，一般使用VGG作为特征提取器。

## 【十七】Accuracy、Precision、Recall、F1 Scores的相关概念？

首先Rocky介绍一下相关名词：

1. TP（True Positive）: 预测为正，实际为正
2. FP（False Positive）: 预测为正，实际为负
3. TN（True Negative）：预测为负，实际为负
4. FN（false negative）: 预测为负，实际为正

Accuracy、Precision、Recall、F1 Scores的公式如下所示：

![](https://files.mdnice.com/user/33499/6a0d964a-f67f-41b4-ba23-60974dc15420.png)

Accuracy（准确率）：分类正确的样本数占样本总数的比例。

Precision（精准度/查准率）：当前预测为正样本类别中被正确分类的样本比例。

Recall（召回率/查全率）：预测出来的正样本占正样本总数的比例。

F1-score是Precision和Recall的综合。F1-score越高，说明分类模型越稳健。

## 【十八】梯度爆炸和梯度消失产生的原因及解决方法?

### 梯度爆炸和梯度消失问题

一般在深层神经网络中，我们需要预防梯度爆炸和梯度消失的情况。

梯度消失（gradient vanishing problem）和梯度爆炸（gradient exploding problem）一般随着网络层数的增加会变得越来越明显。

例如下面所示的含有三个隐藏层的神经网络，梯度消失问题发生时，接近输出层的hiden layer3的权重更新比较正常，但是前面的hidden layer1的权重更新会变得很慢，导致前面的权重几乎不变，仍然接近初始化的权重，<font color=DeepSkyBlue>这相当于hidden layer1没有学到任何东西，此时深层网络只有后面的几层网络在学习，而且网络在实际上也等价变成了浅层网络</font>。

![](https://img-blog.csdnimg.cn/2020071110042155.png)

### 产生梯度爆炸和梯度消失问题的原因

我们来看看看反向传播的过程：

（假设网络每一层只有一个神经元，并且对于每一层$y_{i} = \sigma(z_{i}) = \sigma(w_{i}x_{i} + b_{i})$）

![](https://img-blog.csdnimg.cn/20200711101713569.png)

可以推导出：

![](https://img-blog.csdnimg.cn/20200711101729614.png)

而sigmoid的导数$\sigma^{'}(x)$如下图所示：

![](https://img-blog.csdnimg.cn/20200711101845385.png)

可以知道，$\sigma^{'}(x)$的最大值是$\frac{1}{4}$，而我们初始化的权重$|w|$通常都小于1，因此$\sigma^{'}(x)|w| <= \frac{1}{4}$，而且链式求导层数非常多，不断相乘的话，最后的结果越来越小，趋向于0，就会出现梯度消失的情况。

梯度爆炸则相反，$\sigma^{'}(x)|w| > 1$时，不断相乘结果变得很大。

<font color=DeepSkyBlue>梯度爆炸和梯度消失问题都是因为网络太深，网络权重更新不稳定造成的，本质上是梯度方向传播的连乘效应。</font>

### 梯度爆炸和梯度消失的解决方法

1. 使用预训练加微调策略。
2. 进行梯度截断。
3. 使用ReLU、LeakyReLU等激活函数。
4. 引入BN层。
5. 使用残差结构。
6. 使用LSTM思想。

## 【十九】数据EDA逻辑（Exploratory Data Analysis）？

1. 导入相应的Modules（numpy，pandas，matplotlib，PIL等）
2. 阅读了解所有的数据文件（图片数据，类别文件，辅助文件等）
3. 数据类别特征分析（数据类别总数，数据类别的平衡度，数据尺寸，噪声数据等）
4. 数据可视化二次分析（直观了解不同类别的区别）

## 【二十】K折交叉验证逻辑？

### K折交叉验证的作用

当有多个不同的模型（结构不同、超参数不同等）可以选择时，我们通过K折交叉验证来选取对于特定数据集最好的模型。

### K折交叉验证的流程

1. 将含有$N$个样本的数据集，分成$K$份，每份含有$\frac{N}{K}$个样本。选择其中一份作为验证集，另外$K-1$份作为训练集，验证集集就有$K$种情况。
2. 在每种情况中，用训练集训练模型，用验证集测试模型，计算模型的泛化误差。
3. 交叉验证重复$K$次，平均$K$次的结果作为模型最终的泛化误差。
4. $K$的取值一般在$[2，10]$之间。$K$折交叉验证的优势在于，同时重复运用随机产生的子样本进行训练和验证，$10$折交叉验证是最常用的。
5. 训练集中样本数量要足够多，一般至少大于总样本数的50%。
6. 训练集和验证集必须从完整的数据集中均匀采样。均匀采样的目的是希望减少训练集、验证集与原数据集之间的偏差。当样本数量足够多时，通过随机采样，便可以实现均匀采样的效果。

### 5折交叉验证举例

5折交叉验证(5-fold cross-validation)用来验证从不同的模型中选取最优的模型（最合适的模型）。将数据集分成5份，轮流将其中4份作为训练数据，1份作为验证数据，进行试验。每次试验都会得出相应的正确率。**5次的结果的正确率的平均值作为对算法精度的估计**。同时对不同的模型（如CNN、SVM、LR等）做上述相同的操作，得出每个模型在特定数据集上的平均能力，从中选优。

**例子：**

假设我们有一个特定数据集，我们想从YOLOv4、Mask R-CNN、SSD、Faster R-CNN、RetinaNet这五个模型中选取在这个特定数据集中有最好效果的一个模型作为baseline，我们可以进行交叉验证来进行判断：

**步骤：**

1. 将数据集分成5份。
2. 对于每一个模型，for i = 1， 2， 3， 4，5，每个for循环里将除了第i份的所有数据作为训练集用于训练，得到参数；再将参数在第i份数据上进行验证，得到评价结果。
3. 最后我们可以得到5个模型的结果，每个模型有5个验证结果。将每个模型的结果取平均值，得到该模型的平均结果。
4. 5个模型中平均结果最好的模型就是我们想要的最优模型。

## 【二十一】KL散度相关概念

KL散度（Kullback-Leibler divergence），可以以称作相对熵（relative entropy）或信息散度（information divergence）。<font color=DeepSkyBlue>KL散度的理论意义在于度量两个概率分布之间的差异程度，当KL散度越大的时候，说明两者的差异程度越大；而当KL散度小的时候，则说明两者的差异程度小</font>。如果两者相同的话，则该KL散度应该为0。

接下来我们举一个具体的🌰：

我们设定两个概率分布分别为$P$和$Q$，在设定为连续随机变量的前提下，他们对应的概率密度函数分别为$p(x)$和$q(x)$。如果我们用$q(x)$去近似$p(x)$，则KL散度可以表示为：

$$KL(P||Q) = \int p(x)\log \frac{p(x)}{q(x)}dx $$

从上面的公式可以看出，当且仅当$P=Q$时，$KL(P||Q) = 0$。此外我们可以知道<font color=DeepSkyBlue>KL散度具备非负性</font>，即$KL(P||Q) >= 0$。并且从公式中我们也发现，<font color=DeepSkyBlue>KL散度不具备对称性</font>，也就是说$P$对于$Q$的KL散度并不等于$Q$对于$P$的KL散度。因此，**KL散度并不是一个度量（metric），即KL散度并非距离**。

我们再来看看离散的情况下用$q(x)$去近似$p(x)$的KL散度的公式：

$$KL(P||Q) = \sum p(x)\log \frac{p(x)}{q(x)} $$

接下来我们对上面的式子进行展开：

$$KL(P||Q) = \sum p(x)\log \frac{p(x)}{q(x)}  = -\sum p(x)\log(q(x)) + \sum p(x)\log(p(x)) = H(P,Q) - H(P)$$

最后得到的第一项称作$P$和$Q$的交叉熵（cross entropy），后面一项就是熵。

在信息论中，熵代表着信息量，$H(P)$代表着基于$P$分布自身的编码长度，也就是最优的编码长度（最小字节数）。而$H(P,Q)$则代表着用$Q$的分布去近似$P$分布的信息，自然需要更多的编码长度。并且两个分布差异越大，需要的编码长度越大。所以两个值相减是大于等于0的一个值，代表冗余的编码长度，也就是两个分布差异的程度。所以<font color=DeepSkyBlue>KL散度在信息论中还可以称为相对熵（relative entropy）</font>。

对深度学习中的生成模型来说，我们希望最小化真实数据分布与生成数据分布之间的KL散度，从而使得生成数据尽可能接近真实数据的分布。在实际场景中，我们是几乎不可能知道真实数据分布$P_{data}(x)$的，我们使用训练数据形成的生成分布在逼近$P_{data}(x)$。

## 【二十二】JS散度相关概念

JS散度全称Jensen-Shannon散度，简称JS散度。在概率统计中，<font color=DeepSkyBlue>JS散度也与KL散度一样具备了测量两个概率分布相似程度的能力，它的计算方法基于KL散度，继承了KL散度的非负性等，但有一点重要的不同，JS散度具备了对称性</font>。

JS散度的公式如下所示，我们设定两个概率分布为$P$和$Q$，另外我们还设定$M = 0.5 \times (P + Q)$，KL为KL散度公式。

$$JSD(P||Q) = \frac{1}{2}KL(P||M) + \frac{1}{2}KL(Q||M) $$

如果我们把KL散度公式写入展开的话，结果如下所示：

$$JSD(P||Q) = \int p(x)\log \frac{p(x)}{\frac{p(x) +q(x)}{2}} dx+ \int q(x)\log \frac{q(x)}{\frac{p(x) +q(x)}{2}}dx$$

深度学习中使用KL散度和JS散度进行度量的时候存在一个问题：

如果两个分布$P$，$Q$离得很远，完全没有重叠的时候，那么KL散度值是没有意义的，而JS散度值是一个常数$\log2$。这对以梯度下降为基础的深度学习算法有很大影响，这意味梯度为0，即梯度消失。

## 【二十三】K-means算法逻辑？

K-means算法是<font color=DeepSkyBlue>一个实用的无监督聚类算法，其聚类逻辑依托欧式距离，当两个目标的距离越近，相似度越大</font>。对于给定的样本集，按照样本之间的距离大小，将样本集划分为$K$个簇。让簇内的点尽量紧密的连在一起，而让簇间的距离尽量的大。

**K-means的主要算法步骤**：

1. 选择初始化的$k$个样本作为初始聚类中心$D = \{ D_{1}, D_{2}, D_{3}, ..., D_{k} \}$。
2. 针对数据集中每个样本$x_{i}$，计算它到$k$个聚类中心的距离并将其分到距离最小的聚类中心所对应的类中.
3. 针对每个类别$D_{j}$，重新计算它的聚类中心$D_{j} = \frac{1}{|c_{j}|}\sum_{x\in c_{j}}x$。（即属于该类的所有样本的质心）；
4. 重复上面2和3两步的操作，直到达到设定的中止条件（迭代次数、最小误差变化等）。

**K-Means的主要优点**：

1. 原理简单，实现容易，收敛速度快。
2. 聚类效果较优。
3. 算法的可解释度比较强。
4. 主要需要调参的参数仅仅是簇数k。

**K-Means的主要缺点**：

1. K值需要人为设定，不好把握。
2. 对初始的簇中心敏感，不同选取方式会得到不同结果。
3. 对于不是凸的数据集比较难收敛。
4. 如果各隐含类别的数据不平衡，比如各隐含类别的数据量严重失衡，或者各隐含类别的方差不同，则聚类效果不佳。
5. 迭代结果只是局部最优。
6. 对噪音和异常点比较的敏感。

## 【二十四】K近邻算法逻辑？

K近邻（K-NN）算法<font color=DeepSkyBlue>计算不同数据特征值之间的距离进行分类</font>。存在一个样本数据集合，也称作训练数据集，并且数据集中每个数据都存在标签，即我们知道每一个数据与所属分类的映射关系。接着输入没有标签的新数据后，在训练数据集中找到与该新数据最邻近的K个数据，然后提取这K个数据中占多数的标签作为新数据的标签<font color=DeepSkyBlue>（少数服从多数逻辑）</font>。

**K近邻算法的主要步骤**：

1. 计算新数据与各个训练数据之间的距离。
2. 按照距离的递增关系进行排序。
3. 选取距离最小的K个点。
4. 确定前K个点所在类别的出现频率。
5. 返回前K个点中出现频率最高的类别作为新数据的预测分类。

![](https://files.mdnice.com/user/33499/1923b502-8c67-491e-9fb4-402c4e29bfdb.png)

K近邻算法的结果很大程度取决于K的选择。其距离计算一般使用欧氏距离或曼哈顿距离等经典距离度量。

**K近邻算法的主要优点**：

1. 理论成熟，思想简单，既可以用来做分类又可以做回归。
2. 可以用于非线性分类。
3. 对数据没有假设，准确度高，对异常点不敏感。
4. 比较适用于数据量比较大的场景，而那些数据量比较小的场景采用K近邻算法算法比较容易产生误分类情况。

**K近邻算法的主要缺点**：

1. 计算复杂性高；空间复杂性高。
2. 样本不平衡的时候，对稀有类别的预测准确率低。
3. 是慵懒散学习方法，基本上不学习，导致预测时速度比起逻辑回归之类的算法慢。
4. 可解释性不强。
