# 目录
- [二叉树经典问题](#二叉树经典问题)
- [数组经典问题（双指针、滑动窗口、二分）](#数组经典问题（双指针、滑动窗口、二分）)
- [回溯算法经典问题](#回溯算法经典问题)
- [动态规划经典问题](#动态规划经典问题)
- [基础数据结构经典问题（链表、队列、栈）](#基础数据结构经典问题（链表、队列、栈）)
- [字符串经典问题](#字符串经典问题)
- [基础图论问题](#基础图论问题)
- [基础计算几何问题](#基础计算几何问题)


## 二叉树经典问题

### 1. 什么是满二叉树、完全二叉树、完美二叉树、二叉搜索树和平衡二叉树？

下面逐个解释这些概念。

满二叉树（Full Binary Tree）是一种特殊的二叉树结构，**其中每个节点要么是叶子节点（没有子节点），要么有两个子节点。** 这意味着每一层上的节点都是完全填满的。

<div align="center">
    <img src='images/满二叉树.svg' alt="满二叉树示例图" />
</div>

完美二叉树（Perfect Binary Tree）是一种特殊的二叉树结构，**其中每个节点要么是叶子节点（没有子节点），要么有两个子节点，并且左右子树都完全相同。** 这意味着每一层上的节点都是完全填满的。和满二叉树最大的不同在于，完美二叉树不是节点粒度上的填满，而是层粒度上的填满。

<div align="center">
    <img src='images/完美二叉树.svg' alt="完美二叉树示例图" />
</div>

完全二叉树（Complete Binary Tree）是一种特殊的二叉树结构，**其中除了最后一层节点，其他层节点都是满的，并且最后一层节点从左向右依次排布。** 这是一种完美二叉树的弱化版本，因为完美二叉树尽管拥有很多很好的性质，但是最后一层的节点数量会指数上升。而完全二叉树是一种可以动态决定最后一层节点数量的二叉树结构，同时保证了完美二叉树的一些良好性质（平衡性），主要用于实现堆数据结构。

<div align="center">
    <img src='images/完全二叉树.svg' alt="完全二叉树示例图" />
</div>

二叉搜索树是一种有序的二叉树，其中每个节点的值都满足一定的排序规则：**对于任意一个节点，其左子树上所有节点的值都小于该节点的值，而右子树上所有节点的值都大于该节点的值。** 二叉搜索树是一种常见的数据结构，其中每一个子树也是二叉搜索树，利用这个性质可以递归构造二叉搜索树。

<div align="center">
    <img src='images/二叉搜索树.svg' alt="二叉搜索树示例图" />
</div>

平衡二叉树是一种特殊的二叉搜索树，它保持二叉树的高度尽可能小，从而确保查找、插入、删除操作的时间复杂度尽量接近 $O(\log n)$ 。平衡二叉树需要定义**平衡**规则，而由于二叉树的操作时间复杂度和树的高度直接相关，所以平衡二叉树的规则基本都是限制住树的高度。最常见的两种平衡二叉树是 AVL 树和红黑树，在 AVL 树中，任何节点的两个子树的高度差最多为 1，而红黑树更加复杂，想了解更多可以参考[深入理解红黑树](https://blog.csdn.net/m0_51156601/article/details/133272699)。


### 2. 给定节点总数 $n$ ，完全二叉树可能的最小高度是多少？

高度（从1开始）为$h$的完美二叉树有 $2^h-1$ 个节点。那么可以得到高度为 $h$ 的完全二叉树的节点数量 $n$ 满足 $2^{h-1}\le n\le 2^h-1$ 。于是给定节点数量 $n$ ，我们试图找到第一个 $h$ ，其满足 $2^h-1 \ge n$ ，那么就可以得到最小的高度 $h_{min}=\lceil\log_2(n+1)\rceil$ 。


### 3. 给定节点总数 $n$ ，这有可能是一棵满二叉树吗？

满二叉树的节点数量 $n=2*h-1$ ，所以只需要判断 $n+1$ 是否为偶数即可。

### 4. 二叉搜索树的前驱后继怎么找（迭代实现）？

下面给出二叉树的寻找前驱的迭代实现。

```python
class TreeNode:
    def __init__(self, val=0, parent=None, left=None, right=None):
        self.val = val
        self.left = left
        self.right = right
        self.parent = parent

def find_preprocessor(root, val):
    cur = self.root
    # 找到val的位置
    while cur and cur.val != val:
        if val < cur.val:
            cur = cur.left
        else:
            cur = cur.right
    if not cur:
        return None
    if cur.left:
        # 如果存在左子树，那么前驱就是左子树的最右节点
        cur = cur.left
        while cur.right:
            cur = cur.right
        return cur
    # 否则一直往上走，直到 cur != cur.parent.left
    pa = cur.parent
    while pa and pa.left != cur:
        cur = pa
        pa = cur.parent
    return pa
```
### 5. 二叉搜索树的怎么删除一个节点？

二叉搜索树的删除操作没有那么简单，总共可以分为以下几种情况：
1. 删除的节点是叶子节点，直接删除即可。
2. 删除的节点只有一个子节点，那么直接将子节点替换到删除节点的位置即可。
3. 删除的节点有两个子节点，那么需要找到这个节点的右子树中的最小节点，将这个节点的值替换到删除节点的位置，然后删除这个最小节点即可。

<div align="center">
    <img src='images/二叉搜索树删除.svg' alt="二叉搜索树删除节点示例图" />
</div>

下面是实现的参考代码：

```python
def tranplant(root, u, v):
    # 移植子树 v 到 u 的位置，并且调整关系
    if u.parent is None:
        root = v
    elif u == u.parent.left: 
        u.parent.left = v
    else:
        u.parent.right = v
    if v:
        v.parent = u.parent

def delete(root, val):
    cur = root
    # 找到 cur 的位置
    while cur and cur.val != val:
        if val < cur.val:
            cur = cur.left
        else:
            cur = cur.right
    if not cur:
        return None
    if cur.left is None:
        tranplant(root, cur, cur.right)
    elif cur.right is None:
        tranplant(root, cur, cur.left)
    else:
        y = cur.right
        while y.left: 
            y = y.left
        if y.parent != cur:
            tranplant(root, y, y.right)
            y.right = cur.right
            y.right.parent = y
        tranplant(root, cur, y)
        y.left = cur.left
        y.left.parent = y
```
### 6. 结点数量为 $n$ 的二叉树，有多少种不同的结构？

由于不同的二叉树结构决定了递归的顺序问题（出栈和入栈），令 $1$ 表示进栈，$0$ 表示出栈，则可转化为求一个 $2n$ 位、含 $n$ 个 $1$、$n$ 个 $0$ 的二进制数，满足从左往右扫描到任意一位时，经过的 $0$ 数不多于 $1$ 数。显然含n个1、n个 $0$ 的 $2n$ 位二进制数共有 $\binom{2n}{n}$ 个，下面考虑不满足要求的数目。

假设其中不合法的序列在位置 $2m+1$ 处，此时恰好 $0$ 的数量比 $1$ 多一位，那么必然后面的有 $1$ 的数量比 $ 多一位，具体而言，$0$ 有 $n-m-1$ 位，$1$ 有 $n-m$ 位。我们将 $2m+2$ 及之后的序列进行反转，即可得到一个包含了 $n+1$ 个 $0$，$n-1$ 个 $1$ 的序列。注意这是一个双射的过程，即一个不合法的序列经过构造始终得到唯一的一个包含了 $n+1$ 个 $0$，$n-1$ 个 $1$ 的序列，而反过来该序列唯一对应一个不合法的序列。下面证明：

定义映射 $f$ ：从不满足条件的 $n$ 个 $1$ 和 $n$ 个 $0$ 的序列到 $n+1$ 个 $0$ 和 $n-1$ 个$1$ 的序列。
映射 $f$ 的构造：找到第一个违反条件的位置（称为关键位置）将此位置之后的所有 $0$ 变 $1$ ，$1$ 变 $0$ 。

证明 $f$ 是单射（一对一）：

假设两个不同的不满足条件的序列 A 和 B 映射到同一个序列

- A 和 B 的关键位置必然相同（否则映射结果会不同）
- 如果 A 和 B 在关键位置之前有任何不同，映射后仍然不同
- 如果 A 和 B 在关键位置之后有任何不同，由于0和1互换，映射后仍然不同

因此，不可能有两个不同的序列映射到同一个序列。

证明 $f$ 是满射（映上）：

对于任何 $n+1$ 个 $0$ 和 $n-1$ 个 $1$ 的序列 $S$ ，从左到右扫描，必然存在一个位置，$0$ 的数量比 $1$ 的数量多2（因为总共多2个0）。这个位置就是我们寻找的关键位置，
将此位置之后的 $0$ 和 $1$ 互换，得到一个 $n$ 个 $1$ 和 $n$ 个 $0$ 的序列 $T$。$T$ 在关键位置之前满足条件，在关键位置不满足条件，因此 $T$ 是一个不满足原条件的序列，且 $f(T) = S$ 。

证明 $f$ 的逆映射：

对于任何 $n+1$ 个 $0$ 和 $n-1$ 个 $1$ 的序列，找到 $0$ 比 $1$ 多2的位置（一定存在且唯一）。将此位置之后的 $0$ 和 $1$ 互换，这个过程是上述映射的逆过程。

证毕。

所以合法的序列（也就是二叉树不同结构数量）等于：

$$
\binom{2n}{n} - \binom{2n}{n+1}
$$

也就是卡特兰数，其实卡特兰数还满足以下的性质：

$$
C_0 = 1, C_{n+1} = \sum_{i=0}^{n} C_i C_{n-i}
$$

$C_i$ 可以看成是左子树的数量， $C_{n-i}$ 可以看成是右子树的数量，根据乘法原理即可得到总的数量。

## 数组经典问题（双指针、滑动窗口、二分）


## 回溯算法经典问题


## 动态规划经典问题


## 基础数据结构经典问题（链表、队列、栈）


## 字符串经典问题


## 基础图论问题


## 基础计算几何问题


