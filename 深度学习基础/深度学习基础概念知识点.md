<h1 id="目录">目录</h1>

- [1.反向传播算法（BP）的概念及简单推导](#user-content-1反向传播算法（bp）的概念及简单推导)
- [2.滑动平均的相关概念](#user-content-2滑动平均的相关概念)
- [3.什么是模型微调(fine-tuning)?](#user-content-3什么是模型微调(fine-tuning)?)

<h1 id="1反向传播算法（bp）的概念及简单推导">1.反向传播算法（BP）的概念及简单推导</h1>

<font color=DeepSkyBlue>反向传播（Backpropagation，BP）算法是一种与最优化方法（如梯度下降法）结合使用的，用来训练人工神经网络的常见算法</font>。BP算法对网络中所有权重计算损失函数的梯度，并将梯度反馈给最优化方法，用来更新权值以最小化损失函数。<font color=DeepSkyBlue>该算法会先按前向传播方式计算（并缓存）每个节点的输出值，然后再按反向传播遍历图的方式计算损失函数值相对于每个参数的偏导数</font>。

接下来我们以全连接层，使用sigmoid激活函数，Softmax+MSE作为损失函数的神经网络为例，推导BP算法逻辑。由于篇幅限制，这里只进行简单推导，后续Rocky将专门写一篇PB算法完整推导流程，大家敬请期待。

首先，我们看看sigmoid激活函数的表达式及其导数：

$$sigmoid表达式：\sigma(x) = \frac{1}{1+e^{-x}}$$
$$sigmoid导数：\frac{d}{dx}\sigma(x) = \sigma(x) - \sigma(x)^2 = \sigma(1- \sigma)$$

可以看到sigmoid激活函数的导数最终可以表达为输出值的简单运算。

我们再看MSE损失函数的表达式及其导数：

$$MSE损失函数的表达式：L = \frac{1}{2}\sum^{K}_{k=1}(y_k - o_k)^2$$

其中 $y_k$ 代表ground truth（gt）值， $o_k$ 代表网络输出值。

$$MSE损失函数的偏导：\frac{\partial L}{\partial o_i} = (o_i - y_i)$$

由于偏导数中单且仅当 $k = i$ 时才会起作用，故进行了简化。

接下来我们看看全连接层输出的梯度：

![](https://files.mdnice.com/user/33499/4f1b33bf-53c7-440e-811d-644c9956414a.png)

$$MSE损失函数的表达式：L = \frac{1}{2}\sum^{K}_{i=1}(o_i^1 - t_i)^2$$

$$MSE损失函数的偏导：\frac{\partial L}{\partial w_{jk}} = (o_k - t_k)o_k(1-o_k)x_j$$

我们用 $\delta_k = (o_k - t_k)o_k(1-o_k)$ ，则能再次简化：

$$MSE损失函数的偏导：\frac{dL}{dw_{jk}} = \delta_kx_j$$

最后，我们看看那PB算法中每一层的偏导数：

![](https://files.mdnice.com/user/33499/182e5d6f-711b-496f-86af-c86a8f135623.png)

输出层：
$$\frac{\partial L}{\partial w_{jk}} = \delta_k^K o_j$$
$$\delta_k^K = (o_k - t_k)o_k(1-o_k)$$

倒数第二层：
$$\frac{\partial L}{\partial w_{ij}} = \delta_j^J o_i$$
$$\delta_j^J = o_j(1 - o_j) \sum_{k}\delta_k^Kw_{jk}$$

倒数第三层：
$$\frac{\partial L}{\partial w_{ni}} = \delta_i^I o_n$$
$$\delta_i^I = o_i(1 - o_i) \sum_{j}\delta_j^Jw_{ij}$$

像这样依次往回推导，再通过梯度下降算法迭代优化网络参数，即可走完PB算法逻辑。

<h1 id="2滑动平均的相关概念">2.滑动平均的相关概念</h1>

滑动平均（exponential moving average），或者叫做指数加权平均（exponentially weighted moving avergae），可以用来估计变量的局部均值，<font color=DeepSkyBlue>使得变量的更新与一段时间内的历史取值有关</font>。

变量 $v$ 在 $t$ 时刻记为 $v_{t}$ ， $\theta_{t}$ 为变量 $v$ 在 $t$ 时刻训练后的取值，当不使用滑动平均模型时 $v_{t} = \theta_{t}$ ，在使用滑动平均模型后， $v_{t}$ 的更新公式如下：

![](https://img-blog.csdnimg.cn/20200805140509325.png#pic_center)

上式中， $\beta\epsilon[0,1)$ 。 $\beta = 0$ 相当于没有使用滑动平均。

$t$ 时刻变量 $v$ 的滑动平均值大致等于过去 $1/(1-\beta)$ 个时刻 $\theta$ 值的平均。并使用bias correction将 $v_{t}$ 除以 $(1 - \beta^{t})$ 修正对均值的估计。

加入Bias correction后， $v_{t}$ 和 $v_{biased_{t}}$ 的更新公式如下：

![](https://img-blog.csdnimg.cn/20200805140434908.png#pic_center)

当 $t$ 越大， $1 - \beta^{t}$ 越接近1，则公式（1）和（2）得到的结果（ $v_{t}$ 和 $v_{biased_{1}}$ ）将越来越接近。

当 $\beta$ 越大时，滑动平均得到的值越和 $\theta$ 的历史值相关。如果 $\beta = 0.9$ ，则大致等于过去10个 $\theta$ 值的平均；如果 $\beta = 0.99$ ，则大致等于过去100个 $\theta$ 值的平均。

下图代表不同方式计算权重的结果：

![](https://img-blog.csdnimg.cn/20200805141002734.png)

![](https://img-blog.csdnimg.cn/20200805141448823.png)

如上图所示，滑动平均可以看作是变量的过去一段时间取值的均值，<font color=DeepSkyBlue>相比对变量直接赋值而言，滑动平均得到的值在图像上更加平缓光滑，抖动性更小，不会因为某种次的异常取值而使得滑动平均值波动很大</font>。

**滑动平均的优势：** 占用内存少，不需要保存过去10个或者100个历史 $\theta$ 值，就能够估计其均值。滑动平均虽然不如将历史值全保存下来计算均值准确，但后者占用更多内存，并且计算成本更高。

**为什么滑动平均在测试过程中被使用？**

<font color=DeepSkyBlue>滑动平均可以使模型在测试数据上更鲁棒（robust）</font>。

采用随机梯度下降算法训练神经网络时，使用滑动平均在很多应用中都可以在一定程度上提高最终模型在测试数据上的表现。

训练中对神经网络的权重 $weights$ 使用滑动平均，之后在测试过程中使用滑动平均后的 $weights$ 作为测试时的权重，这样在测试数据上效果更好。因为滑动平均后的 $weights$ 的更新更加平滑，对于随机梯度下降而言，更平滑的更新说明不会偏离最优点很远。比如假设decay=0.999，一个更直观的理解，在最后的1000次训练过程中，模型早已经训练完成，正处于抖动阶段，而滑动平均相当于将最后的1000次抖动进行了平均，这样得到的权重会更加鲁棒。

<h1 id="3什么是模型微调(fine-tuning)?">3.什么是模型微调(fine-tuning)?</h1>

在AI行业中，模型微调（Fine-tuning）是一种基础有效的技术，特别适用于迁移学习场景，其中预训练模型的参数被稍作训练调整以适应新的、但与原始训练任务相似的任务。这种方法非常适合于数据量有限的情况，可以显著提高模型的性能和泛化能力。

### 模型微调的基本步骤：

1. **选择预训练模型**：
   - 开始微调之前，首先需要一个已经在相关任务上预训练好的模型，通常这些模型在大规模数据集（如ImageNet、Laion等）上进行预训练。因为这些模型已经学习到了丰富的特征表示，可以作为新任务的起点。

2. **初始化**：
   - 微调时，通常保留预训练模型的大部分或所有权重，作为新任务训练的初始化点。

3. **修改模型结构**：
   - 根据新任务的需求，可能需要对模型的最后几层进行修改。例如，在图像分类任务中，最后的全连接层（输出层）可能需要根据新任务的类别数进行调整。

4. **重新训练**：
   - 在新的数据集上继续训练模型。通常只需重新训练模型的一部分，特别是那些针对特定任务调整过的层，而其他层可以保持原始预训练时的参数或者以较小的学习率进行微调，以避免过度拟合。

5. **调整学习率**：
   - 微调时通常使用比原始预训练时更小的学习率，这有助于保持已经学习到的有用特征，并仅对它们进行精细的调整。

### 模型微调的应用场景：

- **AIGC**：
- **传统深度学习**：
- **自动驾驶**：

### 微调的好处：

- **加速训练**：由于模型从有效的初始状态开始学习，微调通常比从头开始训练快得多。
- **需要更少的数据**：微调可以在相对较少的数据上进行，因为模型已经从预训练中获得了大量的通用知识。
- **提高性能**：通过利用预训练模型的知识，可以提高模型在新任务上的表现，特别是当新任务的数据不足以从头开始训练复杂模型时。

总的来说，模型微调是一种高效利用已有知识以适应新任务的方法，特别适用于数据资源有限的场景。
