# 目录
- [1.C/C++中面向对象的相关知识](#1.cc中面向对象的相关知识)
- [2.C/C++中struct的内存对齐与内存占用计算？](#2.cc中struct的内存对齐与内存占用计算？)
- [3.C/C++中智能指针的定义与作用？](#3.cc中智能指针的定义与作用？)
- [4.C/C++中程序的开发流程？](#4.cc中程序的开发流程？)
- [5.C/C++中数组和链表的优缺点？](#5.cc中数组和链表的优缺点？)
- [6.C/C++中的new和malloc有什么区别？](#6.cc中的new和malloc有什么区别？)
- [7.C/C++中野指针的概念？](#7.cc中野指针的概念？)
- [8.C/C++中内存泄漏以及解决方法？](#8.cc中内存泄漏以及解决方法？)
- [9.C/C++中面向对象和面向过程的区别？](#9.cc中面向对象和面向过程的区别？)
- [10.C/C++中常用容器功能汇总](#10.cc中常用容器功能汇总)
  - [vector（数组）](#vector（数组）)
  - [queue（队列）](#queue（队列）)
  - [deque（双端队列）](#deque（双端队列）)
  - [set（集合）](#set（集合）)
  - [unordered_set（无序集合）](#unordered_set（无序集合）)
  - [unordered_map](#unordered_map)
- [11.C/C++中指针和引用的区别](#11.cc中指针和引用的区别)
- [12.C/C++中宏定义的相关知识](#12.cc中宏定义的相关知识)
- [13.C/C++中typedef关键字的相关知识](#13.cc中typedef关键字的相关知识)
- [14.声明和定义的区别是什么？](#14.声明和定义的区别是什么？)
- [15.i++和++i哪个执行效率高](#15.i++和++i哪个执行效率高)
- [16.数组名是什么？](#16.数组名是什么？)
- [17.C++中小数用二进制如何表示？](#17.C++中小数用二进制如何表示)
- [18.C++中什么是大端、小端？](#18.C++中什么是大端、小端？)
- [19.C++里有哪些类型转换运算符？](#19.C++里有哪些类型转换运算符？)
- [20.C++中赋值与初始化的区别](#20.C++中赋值与初始化的区别)
- [21.C++中异常处理机制](#21.C++中异常处理机制)
- [22.C++中new、delete、malloc、free关系](#22.C++中new、delete、malloc、free关系)
- [23.介绍一下register关键字](#23.介绍一下register关键字)
- [24.介绍一下const关键字](#24.介绍一下const关键字)
- [25.C++中介绍一下delete与 delete []区别](#25.C++中介绍一下delete与delete[]区别)
- [26.介绍一下newoperator和operatornew的区别](#26.介绍一下newoperator和operatornew的区别)
- [27.介绍一下external关键字](#27.介绍一下external关键字)
- [28.介绍一下volatile关键字](#28.C介绍一下volatile关键字)
- [29.介绍一下dynamic在什么时候使用](#29.介绍一下dynamic在什么时候使用)
- [30.介绍一下vector优缺点](#30.介绍一下vector优缺点)
- [31.介绍一下list优缺点](#31.介绍一下list优缺点)
- [32.介绍一下deque优缺点](#32.介绍一下deque优缺点)
- [33.介绍一下map&set优缺点](#33.介绍一下list优缺点)
- [34.介绍一下mutable关键字的作用](#34.介绍一下deque优缺点)
- [35.什么时候用static](#35.什么时候用static)
- [36.容器选择的原则](#36.容器选择的原则)
- [37.什么是迭代器，有哪几种迭代器](#37.什么是迭代器，有哪几种迭代器)
- [38.什么是指针数组、什么是数组指针](#38.什么是指针数组、什么是数组指针)
- [39.指针与数组的区别](#39.指针与数组的区别)
- [40.引用和指针的区别](#40.引用和指针的区别)
- [41.什么是内联函数](#41.什么是内联函数)
- [42.宏函数和自定义函数的区别](#42.宏函数和自定义函数的区别)
- [43.函数调用的步骤](#43.函数调用的步骤)
- [44.什么是纯虚函数抽象类](#44.什么是纯虚函数抽象类)
- [45.函数重载条件](#45.函数重载条件)
- [46.构造函数的特点](#46.构造函数的特点)
- [47.什么是析构函数、析构函数的作用](#47.什么是析构函数、析构函数的作用)
- [48.C++定义常量两种方式是什么？](#48.C++定义常量两种方式是什么？)
- [49.重载函数是否能够通过函数返回值的类型不同来区分？](#49.重载函数是否能够通过函数返回值的类型不同来区分？)
- [50.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”](#50.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？)
- [51.头文件中的ifndef/define/endif有什么作用？](#51.头文件中的ifndef/define/endif有什么作用？)
- [52.＃include<file.h> 与 ＃include "file.h"的区别？](#52.＃include<file.h>与＃include"file.h"的区别？)
- [53.介绍一下C/C++各自的特点？](#53.介绍一下C/C++各自的特点？)
- [54.介绍一下const 用途？](#54.介绍一下const用途？)
- [55.const和#define有什么区别？](#55.const和#define有什么区别？)
- [56.什么是多态？多态有什么作用？](#56.什么是多态？多态有什么作用？)
- [57.重载和覆盖有什么区别？](#57.重载和覆盖有什么区别？)
- [58.空指针和悬垂指针的区别？](#58.空指针和悬垂指针的区别？)
- [59.什么是智能指针？](#59.什么是智能指针？)
- [60.C++空类默认有哪些成员函数？](#60.C++空类默认有哪些成员函数？)
- [61.C++哪一种成员变量可以在一个类的实例之间共享？](#61.C++哪一种成员变量可以在一个类的实例之间共享？)
- [62.继承层次中，为什么基类析构函数是虚函数？](#62.继承层次中，为什么基类析构函数是虚函数？)
- [63.面向对象技术的基本概念是什么，三个基本特征是什么？](#63.面向对象技术的基本概念是什么，三个基本特征是什么？)
- [64.为什么构造函数不能为虚函数？](#64.为什么构造函数不能为虚函数？)
- [65.虚函数是什么？为什么不把所有函数设为虚函数？](#65.虚函数是什么？为什么不把所有函数设为虚函数？)
- [66.什么是多态？多态有什么作用？](#66.什么是多态？多态有什么作用？)
- [67.什么是公有继承、受保护继承、私有继承？](#67.什么是公有继承、受保护继承、私有继承？)
- [68.什么是虚指针？](#68.什么是虚指针？)
- [69.C++如何阻止一个类被实例化？](#69.C++如何阻止一个类被实例化？)
- [70.main函数执行之前会执行什么？执行之后还能执行代码吗？](#70.main函数执行之前会执行什么？执行之后还能执行代码吗？)
- [71.进程和线程的区别是什么？](#71.进程和线程的区别是什么？)
- [72.进程间如何通信？](#72.进程间如何通信？)
- [73.在网络编程中涉及并发服务器，使用多进程与多线程的区别？](#73.在网络编程中涉及并发服务器，使用多进程与多线程的区别？)
- [74.C++中经常要操作的内存分为那几个类别？](#74.C++中经常要操作的内存分为那几个类别？)
- [75.堆和栈的区别有什么？](#75.堆和栈的区别有什么？)
- [76.类使用static成员的优点，如何访问？](#76.类使用static成员的优点，如何访问？)
- [77.介绍一下static数据成员和static成员函数？](#77.介绍一下static数据成员和static成员函数？)
- [78.78.如何引用一个已经定义过的全局变量？](#78.如何引用一个已经定义过的全局变量？)
- [79.介绍一下static关键字的作用。](#79.介绍一下static关键字的作用。)
- [80.一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual,也能实现多态?在子类的空间里，有没有父类的这个函数，或者父类的私有变量?](#80.一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual,也能实现多态?在子类的空间里，有没有父类的这个函数，或者父类的私有变量?)
- [81.完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别。](#81.完成字符串拷贝可以使用sprintf、strcpy及memcpy函数，请问这些函数有什么区别。)
- [82.应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？](#82.应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？)
- [83.C++函数中值的传递方式有哪几种？](#83.C++函数中值的传递方式有哪几种？)
- [84.C++里面是不是所有的动作都是main()引起的？](#84.C++里面是不是所有的动作都是main()引起的？)
- [85.内联函数在编译时是否做参数类型检查？](#85.内联函数在编译时是否做参数类型检查？)
- [86.全局变量和局部变量有什么区别？怎么实现的？操作系统和编译器是怎么知道的？](#86.全局变量和局部变量有什么区别？怎么实现的？操作系统和编译器是怎么知道的？)
- [87.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？](#87.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？)
- [88.程序的局部变量、全局变量、以及动态申请的数据分别存储在哪里？](#88.程序的局部变量、全局变量、以及动态申请的数据分别存储在哪里？)
- [89.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?](#89.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?)
- [90.共享内存安全吗，有什么措施保证?](#90.共享内存安全吗，有什么措施保证?)
- [91.多态实现方式是什么？](#91.多态实现方式是什么？)
- [92.介绍一下c++内存泄漏？](#92.介绍一下c++内存泄漏？)
- [93. C++11 的新特性都有哪些？](#93.C++11的新特性都有哪些？)
- [94. 介绍一下左值和右值引用](#94.介绍一下左值和右值引用)
- [95. 介绍一下C++转型操作符？](#95.介绍一下C++转型操作符？)
- [96. map和unordered_map了解吗？](#96.map和unordered_map了解吗？)
- [97. vector的底层原理和扩容机制是什么？](#97.vector的底层原理和扩容机制是什么？)
- [98. map的底层原理是什么？](#98.map的底层原理是什么？)
- [99. socket与其他通信方式有什么不同？](#99.socket与其他通信方式有什么不同？)
- [100.TCP和UDP的区别是什么，TCP什么时候会重传？](#100.TCP和UDP的区别是什么，TCP什么时候会重传？)


<h2 id="1.cc中面向对象的相关知识">1.C/C++中面向对象的相关知识</h2>
  
面向对象程序设计（Object-oriented programming，OOP）有三大特征 ——封装、继承、多态。

<font color=DeepSkyBlue>封装</font>：把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。
关键字：public, protected, private。不写默认为 private。
1. public 成员：可以被任意实体访问。

2. protected 成员：只允许被子类及本类的成员函数访问。

3. private 成员：只允许被本类的成员函数、友元类或友元函数访问。

<font color=DeepSkyBlue>继承</font>：基类（父类）——> 派生类（子类）

<font color=DeepSkyBlue>多态</font>：即多种状态（形态）。简单来说，我们可以将多态定义为消息以多种形式显示的能力。多态是以封装和继承为基础的。

C++ 多态分类及实现：

1. 重载多态（Ad-hoc Polymorphism，编译期）：函数重载、运算符重载

2. 子类型多态（Subtype Polymorphism，运行期）：虚函数

3. 参数多态性（Parametric Polymorphism，编译期）：类模板、函数模板

4. 强制多态（Coercion Polymorphism，编译期/运行期）：基本类型转换、自定义类型转换

<h2 id="2.cc中struct的内存对齐与内存占用计算？">2.C/C++中struct的内存对齐与内存占用计算？</h2>

<font color=DeepSkyBlue>什么是内存对齐？</font>计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是有效对齐值的倍数。

<font color=DeepSkyBlue>什么是有效对齐值？</font>计算机系统有默认对齐系数n,可以通过#pragma pack(n)来指定。有效对齐值就等与该对齐系数和结构体中最长的数据类型的长度两者最小的那一个值,比如对齐系数是8,而结构体中最长的是int,4个字节,那么有效对齐值为4。
  
<font color=DeepSkyBlue>为什么要内存对齐？</font>假如没有内存对齐机制，数据可以任意存放，现在一个int变量存放在从地址1开始的连续四个字节地址中。当4字节存取粒度的处理器去取数据时，要先从0地址开始读取第一个4字节块,剔除不想要的字节（0地址）,然后从地址4开始读取下一个4字节块,同样剔除不要的数据（5，6，7地址）,最后留下的两块数据合并放入寄存器，这需要做很多工作，整体效率较低。

![](https://files.mdnice.com/user/33499/a93de1ee-1369-4d06-bb7a-136990981fa2.png)

<font color=DeepSkyBlue>struct内存占用如何计算？</font>结构体的内存计算方式遵循以下规则：

1. 数据成员对齐规则：第一个数据成员放在offset为0的地方，以后的每一个成员的offset都必须是该成员的大小与有效对齐值相比较小的数值的整数倍,例如第一个数据成员是int型，第二个是double，有效对齐值为8,所以double的起始地址应该为8,那么第一个int加上内存补齐用了8个字节

2. 结构体作为成员：如果一个结构里有某些结构体成员，则结构体成员要从其内部有效对齐值的整数倍地址开始存储。(比如struct a中存有struct b，b里有char, int, double，那b应该从8的整数倍开始存储)

3. 结构体内存的总大小，必须是其有效对齐值的整数倍，不足的要补齐。

我们来举两个🌰：

```
#include <stdio.h>
#pragma pack(8)
int main()
{
  struct Test
  {
    int a;
    //long double大小为16bytes
    long double b;         
    char c[10];
  };
  printf("%d", sizeof(Test));
  return 0;
} 

struct的内存占用为40bytes
```

```
#include <stdio.h>
#pragma pack(16)
int main()
{
  struct Test
  {
    int a;
    //long double大小为16bytes
    long double b;         
    char c[10];
  }
  printf("%d", sizeof(Test));
  return 0;
}

struct的内存占用为48bytes
```

<h2 id="3.cc中智能指针的定义与作用？">3.C/C++中智能指针的定义与作用？</h2>
  
智能指针是一个类，这个类的构造函数中传入一个普通指针，析构函数中释放传入的指针。智能指针的类都是栈上的对象，所以当函数（或程序）结束时会自动被释放。

（注：不能将指针直接赋值给一个智能指针，一个是类，一个是指针。）

<font color=DeepSkyBlue>常用的智能指针</font>：智能指针在C++11版本之后提供，包含在头文件<memory>中，主要是shared_ptr、unique_ptr、weak_ptr。<font color=DeepSkyBlue>unique_ptr</font>不支持复制和赋值。当程序试图将一个 unique_ptr 赋值给另一个时，如果源 unique_ptr 是个临时右值，编译器允许这么做；如果原来的unique_ptr 将存在一段时间，编译器将禁止这么做。<font color=DeepSkyBlue>shared_ptr</font>是基于引用计数的智能指针。可随意赋值，直到内存的引用计数为0的时候这个内存会被释放。<font color=DeepSkyBlue>weak_ptr</font>能进行弱引用。引用计数有一个问题就是互相引用形成环，这样两个指针指向的内存都无法释放。需要手动打破循环引用或使用weak_ptr。顾名思义，weak_ptr是一个弱引用，只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前需要检查weak_ptr是否为空指针。

<font color=DeepSkyBlue>智能指针的作用</font>：C++11中引入了智能指针的概念，方便管理堆内存。使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，野指针，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

<h2 id="4.cc中程序的开发流程？">4.C/C++中程序的开发流程？</h2>
  
开发一个C++程序的过程通常包括编辑、编译、链接、运行和调试等步骤。

<font color=DeepSkyBlue>编辑</font>：编辑是C++程序开发过程的第一步，它主要包括程序文本的输入和修改。任何一种文本编辑器都可以完成这项工作。当用户完成了C++程序的编辑时，应将输入的程序文本保存为以.cpp为扩展名的文件（保存C++头文件时应以.h为扩展名）。

<font color=DeepSkyBlue>编译</font>：C++是一种高级程序设计语言，它的语法规则与汇编语言和机器语言相比更接近人类自然语言的习惯。然而，计算机能够“看”懂的唯一语言是汇编语言。因此，当我们要让计算机“看”懂一个C++程序时，就必须使用编译器将这个C++程序“翻译”成汇编语言。编译器所做的工作实际上是一种由高级语言到汇编语言的等价变换。

<font color=DeepSkyBlue>汇编</font>：将汇编语言翻译成机器语言指令。汇编器对汇编语言进行一系列处理后最终产生的输出结构称为目标代码，它是某种计算机的机器指令（二进制），并且在功能上与源代码完全等价。保存源代码和目标代码的文件分别称为源文件和目标文件（ .obj）。

<font color=DeepSkyBlue>链接</font>：要将汇编器产生的目标代码变成可执行程序还需要最后一个步骤——链接。链接工作是由“链接器”完成的，它将编译后产生的一个或多个目标文件与程序中用到的库文件链接起来，形成一个可以在操作系统中直接运行的可执行程序。（linux中的.o文件）

<font color=DeepSkyBlue>运行和调试</font>：我们接下来就可以执行程序了。如果出现问题我们可以进行调试debug。

<h2 id="5.cc中数组和链表的优缺点？">5.C/C++中数组和链表的优缺点？</h2>

数组和链表是C/C++中两种基本的数据结构，也是两个最常用的数据结构。

<font color=DeepSkyBlue>数组的特点</font>是在内存中，数组是一块连续的区域，并且数组需要预留空间。<font color=DeepSkyBlue>链表的特点</font>是在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续。链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址。每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据。

<font color=DeepSkyBlue>数组的优缺点</font>：

优点：查询效率高，时间复杂度可以达到O(1)。

缺点：新增和修改效率低，时间复杂度为O(N)；内存分配是连续的内存，扩容需要重新分配内存。

<font color=DeepSkyBlue>链表的优缺点</font>：

优点：新增和修改效率高，只需要修改指针指向即可，时间复杂度可以达到O(1)；内存分配不需要连续的内存，占用连续内存少。

缺点：链表查询效率低，需要从链表头依次查找，时间复杂度为O(N)。

<h2 id="6.cc中的new和malloc有什么区别？">6.C/C++中的new和malloc有什么区别？</h2>
  
new和malloc主要有以下三方面的区别：

1. malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载。
  
2. malloc仅仅分配内存空间，free仅仅回收空间，不具备调用构造函数和析构函数功能，用malloc分配空间存储类的对象存在风险；new和delete除了分配回收功能外，还会调用构造函数和析构函数。
  
3. malloc和free返回的是void类型指针（必须进行类型转换），new和delete返回的是具体类型指针。

<h2 id="7.cc中野指针的概念？">7.C/C++中野指针的概念？</h2>

野指针也叫空悬指针，不是指向null的指针，是未初始化或者未清零的指针。

**产生原因：**

1. 指针变量未及时初始化。

2. 指针free或delete之后没有及时置空。

**解决办法：**

1. 定义指针变量及时初始化活着置空。

2. 释放操作后立即置空。

<h2 id="8.cc中内存泄漏以及解决方法？">8.C/C++中内存泄漏以及解决方法？</h2>

内存泄漏是指己动态分配的堆内存由于某种原因导致程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。

**解决方法：**

造成内存泄漏的主要原因是在使用new或malloc动态分配堆上的内存空间，而并未使用delete或free及时释放掉内存造成的。所以解决方法就是注意new/delete和malloc/free一定要配套使用。

<h2 id="9.cc中面向对象和面向过程的区别？">9.C/C++中面向对象和面向过程的区别？</h2>

面向对象（Object Oriented Programming，OOP）编程模型首先抽象出各种对象（各种类），并专注于对象与对象之间的交互，对象涉及的方法和属性都封装在对象内部。

面向对象的编程思想是一种依赖于类和对象概念的编程方式，一个形象的例子是将大象装进冰箱：

1. 冰箱是一个对象，大象也是一个对象。
2. 冰箱有自己的方法，打开、存储、关闭等；大象也有自己的方法，吃、走路等。
3. 冰箱有自己的属性：长、宽、高等；大象也有自己的属性：体重、高度、体积等。

面向过程（Procedure Oriented Programming，POP）编程模型是将问题分解成若干步骤（动作），每个步骤（动作）用一个函数来实现，在使用的时候，将数据传递给这些函数。

面向过程的编程思想通常采用自上而下、顺序执行的方式进行，一个形象的例子依旧是将大象装进冰箱：

1. 打开冰箱。
2. 把大象装进冰箱。
3. 关闭冰箱。

<h3 id="面向对象和面向过程的区别：">面向对象和面向过程的区别：</h3>

1. <font color=DeepSkyBlue>安全性角度</font>。面向对象比面向过程安全性更高，面向对象将数据访问隐藏在了类的成员函数中，而且类的成员变量和成员函数都有不同的访问属性；而面向过程并没有办法来隐藏程序数据。

2. <font color=DeepSkyBlue>程序设计角度</font>。面向过程通常将程序分为一个个的函数；而面向对象编程中通常使用一个个对象，函数通常是对象的一个方法。

3. <font color=DeepSkyBlue>逻辑过程角度</font>。面向过程通常采用自上而下的方法；而面向对象通常采用自下而上的方法。

4. <font color=DeepSkyBlue>程序扩展性角度</font>。面向对象编程更容易修改程序，更容易添加新功能。

<h2 id="10.cc中常用容器功能汇总">10.C/C++中常用容器功能汇总</h2>

<h3 id="vector（数组）">vector（数组）</h3>

vector是封装动态数组的顺序容器。

成员函数：
1. at():所需元素值的引用。
2. front():访问第一个元素（返回引用）。
3. back():访问最后一个元素（返回引用）。
4. beign():返回指向容器第一个元素的迭代器。
5. end():返回指向容器末尾段的迭代器。
6. empty():检查容器是否为空。
7. size():返回容器中的元素数。
8. capacity():返回当前存储空间能够容纳的元素数。
9.  clear():清除内容。
10. insert():插入元素。
11. erase():擦除元素。
12. push_back():将元素添加到容器末尾。
13. pop_back():移除末尾元素。
14. *max_element(v.begin(), v.end()):返回数组最大值。
15. *min_element(v.begin(), v.end()):返回数组最小值。

<h3 id="queue（队列）">queue（队列）</h3>

queue是容器适配器，他是FIFO（先进先出）的数据结构。

成员函数：
1. front():访问第一个元素（返回引用）。
2. back():访问最后一个元素（返回引用）。
3. empty():检查容器是否为空。
4. size():返回容器中的元素数。
5. push():向队列尾部插入元素。
6. pop():删除首个元素。

<h3 id="deque（双端队列）">deque（双端队列）</h3>

deque是有下标顺序容器，它允许在其首尾两段快速插入和删除。

成员函数：
1. front():访问第一个元素（返回引用）。
2. back():访问最后一个元素（返回引用）。
3. beign():返回指向容器第一个元素的迭代器。
4. end():返回指向容器末尾段的迭代器。
5. empty():检查容器是否为空。
6. size():返回容器中的元素数。
7. clear():	清除内容。
8. insert():插入元素。
9. erase():擦除元素。
10. push_back():将元素添加到容器末尾。
11. pop_back():移除末尾元素。
12. push_front():插入元素到容器起始位置。
13. pop_front():移除首元素。
14. at():所需元素值的引用。 

<h3 id="set（集合）">set（集合）</h3>
集合基于红黑树实现，有自动排序的功能，并且不能存放重复的元素。

成员函数：
1. begin()--返回指向第一个元素的迭代器。

 2. clear()--清除所有元素。

 3. count()--返回某个值元素的个数。

 4. empty()--如果集合为空，返回true。

 5. end()--返回指向最后一个元素的迭代器。

 6. erase()--删除集合中的元素。

 7. find()--返回一个指向被查找到元素的迭代器。

 8. insert()--在集合中插入元素。

 9. size()--集合中元素的数目。

<h3 id="unordered_set（无序集合）">unordered_set（无序集合）</h3>

无序集合基于哈希表实现，不能存放重复的元素。元素类型必须可以比较是否相等，因为这可以确定元素什么时候相等。

成员函数：
1. empty():检查容器是否为空。
2. size():返回容器中的元素数。
3. insert():插入元素。
4.  clear():清除内容。
5. count():返回匹配特定键的元素数量。
6. find():寻找带有特定键的元素。
7. erase()--删除集合中的元素。

<h3 id="unordered_map">unordered_map</h3>

unordered_map是关联容器，含有带唯一键的键-值对。

搜索、插入和元素移除拥有平均常数时间复杂度。

元素在内部不以任何特定顺序排序，而是组织进桶中。元素放进哪个桶完全依赖于其键的哈希。这允许对单独元素的快速访问，因为一旦计算哈希，则它准确指代元素所放进的桶。

成员函数：
1. empty()：检查容器是否为空。
2. size()：返回可容纳的元素数。
3. insert():插入元素。
4.  clear():清除内容。
5. count():返回匹配特定键的元素数量。
6. find():寻找带有特定键的元素。
7. erase()--删除集合中的元素。
  
<h2 id="11.cc中指针和引用的区别">11.C/C++中指针和引用的区别</h2>

C语言的指针让我们拥有了直接操控内存的强大能力，而C++在指针基础上又给我们提供了另外一个强力武器$\to$引用。

首先我们来看一下C++中对象的定义：对象是指一块能存储数据并具有某种类型的内存空间。

一个对象a，它有值和地址&a。运行程序时，计算机会为该对象分配存储空间，来存储该对象的值，我们通过该对象的地址，来访问存储空间中的值。

指针p也是对象，它同样有地址&p和存储的值p，只不过，<font color=DeepSkyBlue>p存储的是其他对象的地址</font>。如果我们要以p中存储的数据为地址，来访问对象的值，则要在p前加引用操作符$*$，即$*p$。

对象有常量（const）和变量之分，既然指针本身是对象，那么指针所存储的地址也有常量和变量之分，<font color=DeepSkyBlue>指针常量</font>是指，指针这个对象所存储的地址是不可改变的，而<font color=DeepSkyBlue>常量指针</font>的意思就是指向常量的指针。

我们可以<font color=DeepSkyBlue>把引用理解成变量的别名</font>。定义一个引用的时候，程序把该引用和它的初始值绑定在一起，而不是拷贝它。<font color=DeepSkyBlue>计算机必须在声明引用r的同时就要对它初始化，并且r一经声明，就不可以再和其他对象绑定在一起了</font>。

实际上，我们也可以把引用看作是通过一个指针常量来实现的，指向的地址不变，地址里的内容可以改变。

接下来我们来看看指针和引用的**具体区别：**

1. 指针是一个新的变量，要占用存储空间，存储了另一个变量的地址，我们可以通过访问这个地址来修改另一个变量。而引用只是一个别名，还是变量本身，不占用具体存储空间，只有声明没有定义。对引用的任何操作就是对变量本身进行操作，以达到修改变量的目的。
2. 引用只有一级，而指针可以有多级。
3. 指针传参的时候，还是值传递，指针本身的值不可以修改，需要通过解引用才能对指向的对象进行操作。引用传参的时候，传进来的就是变量本身，因此变量可以被修改。
4. 引用它一定不为空，因此相对于指针，它不用检查它所指对象是否为空，这样就提高了效率。
5. 引用必须初始化，而指针可以不初始化。

我们可以看下面的代码：

```cpp
int a,b,*p,&r=a;//正确
r=3;//正确：等价于a=3
int &rr;//出错：引用必须初始化
p=&a;//正确：p中存储a的地址，即p指向a
*p=4;//正确：p中存的是a的地址，对a所对应的存储空间存入值4
p=&b//正确：p可以多次赋值，p存储b的地址
```

“&”不仅能表示引用，还可以表示成地址，还有可以作为按位与运算符。这个要根据具体情况而定。比如上面的例子，等号左边的，被解释为引用，右边的被解释成取地址。

引用的操作加了比指针更多的限制条件，保证了整体代码的安全性和便捷性。引用的合理使用可以一定程度避免“指针满天飞”的情况，可以一定程度上提升程序鲁棒性。并且指针与引用底层实现都是一样的，不用担心两者的性能差距。
  
<h2 id="12.cc中宏定义的相关知识">12.C/C++中宏定义的相关知识</h2>

宏定义可以把一个名称指定成任何一个文本。在完成宏定义后，无论宏名称出现在源代码的何处，预处理器都会将其替换成指定的文本。

```
//define 宏名 文本
#define WeThinkIn 666688889999

//define 宏名(参数) 文本
#define R(a,b) (a/b)
//注：带参数的宏替换最好在表达式整体上加括号，避免结果受其他运算影响。
```

<font color=DeepSkyBlue>宏定义的优点</font>：

1. **方便程序修改**，如果一个常量在程序中大量使用，我们可以使用宏定义为其设置一个标识符。当我们想修改这个常量时，直接修改宏定义处即可，不必在程序中海量寻找所有相关位置。
2. **提高程序的运行效率**，使用带参数的宏定义可以完成函数的功能，但同时又比函数节省系统开销，提升程序运行效率。（无需调用函数这个流程）

<font color=DeepSkyBlue>宏定义和函数的区别</font>：

1. 宏在预处理阶段完成替换，之后替换的文本参与编译，相当于是恒等代换过程，运行时不存在函数调用，执行起来更快；而函数调用在运行时需要跳转到具体调用函数。
2. 宏定义没有返回值；函数调用具有返回值。
3. 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型。
4. 宏定义不是说明或者语句，结尾不用加分号。
5. 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用# undef命令；而函数作用域在函数调用处。
  
<h2 id="13.cc中typedef关键字的相关知识">13.C/C++中typedef关键字的相关知识</h2>

我们可以使用typedef关键字来定义自己习惯的数据类型名称，来替代系统默认的基本类型名称以及其他类型等名称。

在工业界中，我们一般在如下两个场景中会见到typedef的身影。

```
// 1.为基本数据类型定义新的类型名
typedef unsigned int WeThinkIn_int;
typedef char* WeThinkIn_point;
  
// 2.为自定义数据类型（结构体、共用体和枚举类型）定义简洁的类型名称
typedef struct target_Object
{
    int x;
    int y;
} WeThinkIn_Object;
```

<font color=DeepSkyBlue>typedef与宏定义的区别</font>：

1. 宏主要用于定义常量及书写复杂的内容；typedef主要用于定义类型别名。
2. 宏替换发生在预处理阶段，属于文本恒等替换；typedef是编译中发挥作用。
3. 宏定义参数没有类型，不进行类型检查；typedef参数具有类型，需要检查类型。
4. 宏不是语句，不用在最后加分号；typedef是语句，要加分号标识结束。
5. 注意对指针的操作，typedef char * p_char和#define p_char char *区别巨大。

<h2 id="14.声明和定义的区别是什么？>14.声明和定义的区别是什么？</h2>
在C++中，声明（declaration）只是告诉编译器某个变量、函数或类型的名称及其类型信息，而定义（definition）则不仅包括声明，还为变量分配内存或为函数提供具体的实现代码。声明可以出现多次，但定义在一个作用域内只能出现一次。

<h2 id="15.i++和++i哪个执行效率高">15.i++和++i哪个执行效率高</h2>
在C++中，`++i`通常比`i++`执行效率更高。原因在于：
- `++i` 是前置递增，直接对变量进行加一操作并返回新值，不需要创建临时对象。
- `i++` 是后置递增，先保存变量的当前值，执行加一操作，然后返回旧值，因此可能需要创建临时对象以存储旧值，这在某些情况下会增加开销。
因此，`++i` 在大多数情况下比 `i++` 更高效。

<h2 id="16.数组名是什么？">16.数组名是什么？</h2>
在C++中，数组名是一个指向数组第一个元素的常量指针。它具有以下特点：
1. 指向数组的首元素：数组名表示数组在内存中的起始地址，即数组第一个元素的地址。
2. 不可修改：数组名是一个常量指针，它的值（即地址）不能被修改。
3. 隐式转换：在许多表达式中，数组名会隐式转换为指向数组第一个元素的指针。例如，在函数调用中传递数组时，实际上传递的是数组首元素的指针。
示例如下：
int arr[5] = {1, 2, 3, 4, 5};
int* ptr = arr; // 数组名 arr 隐式转换为指向 arr[0] 的指针
在这个示例中，`arr` 是数组名，它等同于指向 `arr[0]` 的指针，因此 `ptr` 也指向 `arr[0]`。

<h2 id="17.C++中小数用二进制如何表示">17.C++中小数用二进制如何表示</h2>
小数在计算机中使用二进制表示时，采用的是浮点数表示法。这种表示法包括定点和浮点两种，但浮点数是更常用的方式。浮点数表示法类似于科学计数法，可以表示很大的范围和精度。

<h2 id="18.C++中什么是大端、小端？">18.C++中什么是大端、小端？</h2>

大端（Big-endian）和小端（Little-endian）是指计算机中存储多字节数据时字节的排列顺序：大端将高字节存储在低地址处，低字节存储在高地址处；小端则将低字节存储在低地址处，高字节存储在高地址处。

<h2 id="19.C++里有哪些类型转换运算符？">19.C++里有哪些类型转换运算符？</h2>
C++里有四种类型转换运算符：`static_cast`用于一般类型转换，`dynamic_cast`用于运行时类型安全的多态类型转换，`const_cast`用于修改对象的常量性，`reinterpret_cast`用于低级别的、几乎不受限制的类型转换。这些运算符提供了比传统C风格类型转换更安全和明确的转换方式。

<h2 id="20.C++中赋值与初始化的区别">20.C++中赋值与初始化的区别</h2>
赋值是给已存在的对象重新赋值，而初始化是创建对象时赋予其初始值。赋值操作发生在对象已经存在之后，而初始化操作在对象创建时就完成了。初始化通常在对象声明时通过构造函数完成，而赋值则可以在对象生命周期的任何时刻进行。
const成员和引用是如何初始化的
`const`成员和引用必须通过初始化列表在对象构造函数中进行初始化，因为它们在对象创建后无法被赋值或修改。

<h2 id="21.C++中异常处理机制">21.C++中异常处理机制</h2>
C++异常处理机制通过`try`、`throw`和`catch`关键字实现，`try`块中包含可能引发异常的代码，`throw`用于抛出异常，`catch`块捕获并处理异常，提供了一种结构化的方法来处理运行时错误并确保程序的健壮性。

<h2 id="22.C++中new、delete、malloc、free关系">22.C++中new、delete、malloc、free关系</h2>
`new`和`delete`是C++中用于动态内存分配和释放的运算符。`new`运算符在堆上分配内存并调用构造函数来初始化对象，而`delete`运算符则释放内存并调用析构函数来清理对象。它们提供了类型安全的内存管理方式，适合用于C++中的面向对象编程。

`malloc`和`free`是C语言中用于动态内存分配和释放的函数。`malloc`函数分配指定字节的内存块，但不调用构造函数进行初始化，而`free`函数释放之前使用`malloc`分配的内存块，但不调用析构函数进行清理。它们不具有类型安全性，因此在C++中通常建议使用`new`和`delete`替代。

<h2 id="23.介绍一下register关键字">23.介绍一下register关键字</h2>
`register`关键字用于建议编译器将变量存储在寄存器中以提高访问速度，但现代编译器通常会自行优化变量的存储位置，因此这个关键字的实际影响较小且在C++17中已被弃用。

<h2 id="24.介绍一下const关键字">24.介绍一下const关键字</h2>
`const`关键字用于声明不可修改的变量、指针或成员函数，确保其值或状态在程序运行过程中保持不变，从而增加代码的安全性和可读性。

<h2 id="25.C++中介绍一下delete与delete[]区别">25.C++中介绍一下delete与 delete []区别</h2>
`delete`用于释放单个对象的内存并调用其析构函数，而`delete[]`用于释放数组对象的内存并调用每个元素的析构函数，使用不当会导致未定义行为和潜在的内存泄漏或崩溃。
<h2 id="26.介绍一下newoperator和operatornew的区别">26.介绍一下new operator和operator new 的区别</h2>
`new` operator是C++中的关键字，用于分配内存并调用对象的构造函数，而`operator new`是一个函数，类似于`malloc`，只负责分配内存，不调用构造函数，允许用户自定义内存分配的行为。

<h2 id="27.介绍一下external关键字]">27.介绍一下external关键字]</h2>
`extern`关键字用于声明变量或函数在其他文件中定义，以实现跨文件的访问和共享，避免重复定义，通常用于变量的声明而不是定义，确保链接时能够找到正确的符号。

<h2 id="28.介绍一下volatile关键字]">28.介绍一下volatile关键字]</h2>
`volatile`关键字用于指示编译器一个变量的值可能会被程序外部因素（如硬件或另一个线程）修改，从而阻止编译器对该变量进行优化，确保每次访问都从内存中读取，以保证程序能够正确处理这些变化。

<h2 id="29.介绍一下dynamic在什么时候使用">29.介绍一下dynamic在什么时候使用</h2>
`dynamic_cast`在C++中用于运行时类型安全转换，特别是用于在继承层次结构中向下转换指针或引用，确保转换的合法性，并在转换失败时返回`nullptr`（对于指针）或抛出`std::bad_cast`异常（对于引用）。

<h2 id="30.介绍一下vector优缺点">30.介绍一下vector优缺点</h2>
`std::vector`是C++标准库中的动态数组，具有自动管理内存、支持随机访问、高效插入和删除尾部元素的优点，但在中间位置插入或删除元素时性能较差，并且在重新分配内存时可能导致迭代器失效和性能开销。

<h2 id="31.介绍一下list优缺点">31.介绍一下list优缺点</h2>
`std::list`是C++标准库中的双向链表，具有快速的插入和删除操作，不会导致迭代器失效的优点，但不支持随机访问，且遍历和查找元素的性能相对较差。

<h2 id="32.介绍一下deque优缺点">32.介绍一下deque优缺点</h2>
`std::deque`是C++标准库中的双端队列，支持高效的双端插入和删除操作，允许快速随机访问，适合需要在两端频繁操作的场景，但在中间位置插入和删除元素时性能较差，且与`std::vector`相比，内存使用效率稍低。

<h2 id="33.介绍一下map&set优缺点">33.介绍一下map&set优缺点</h2>
`std::map`和`std::set`是C++标准库中的关联容器，提供高效的键值对存储（`map`）和唯一元素存储（`set`）以及自动排序功能，具有O(log n)的查找、插入和删除性能，但由于底层使用红黑树实现，较`unordered_map`和`unordered_set`（基于哈希表）在特定场景下的访问速度稍慢。

<h2 id="34.介绍一下mutable关键字的作用">34.介绍一下mutable关键字的作用</h2>
`mutable`关键字用于允许对象的成员变量在`const`成员函数中被修改，通常用于需要在逻辑上视为常量但在实现上可能需要改变状态的成员变量，例如缓存或统计信息。

<h2 id="35.什么时候用static">35.什么时候用static</h2>
`static`关键字在C++中用于声明静态变量或函数，其作用包括在局部变量中维持变量的生命周期为整个程序运行期间，在类中共享所有实例之间的成员变量或函数，以及在全局作用域中限制变量或函数的可见性仅在当前编译单元内。

<h2 id="36.容器选择的原则">36.容器选择的原则</h2>
容器选择的原则是根据应用场景的需求来选择适当的容器，考虑因素包括元素的访问方式（顺序访问、随机访问）、插入和删除操作的频率与位置（头部、尾部、中间）、内存使用和迭代器的有效性，例如，选择`vector`用于频繁随机访问，选择`list`用于频繁插入和删除操作，选择`map`或`set`用于需要快速查找和有序存储。

<h2 id="37.什么是迭代器，有哪几种迭代器]">37.什么是迭代器，有哪几种迭代器]</h2>
迭代器是用于遍历容器元素的对象或指针，提供一致的接口来访问容器元素，C++中主要有五种迭代器：输入迭代器（Input Iterator）、输出迭代器（Output Iterator）、前向迭代器（Forward Iterator）、双向迭代器（Bidirectional Iterator）和随机访问迭代器（Random Access Iterator），它们分别适用于不同的遍历需求和容器类型。

<h2 id="38.什么是指针数组、什么是数组指针]">38.什么是指针数组、什么是数组指针]</h2>
指针数组是一个数组，数组中的每个元素都是指针（例如 `int* arr[10]` 是一个包含10个指向整数的指针的数组）；数组指针是一个指针，指向一个数组的首地址（例如 `int (*ptr)[10]` 是一个指向包含10个整数的数组的指针）。

<h2 id="39.指针与数组的区别">39.指针与数组的区别</h2>
指针是一个变量，用于存储内存地址，可以动态指向不同位置，而数组是一块连续的内存区域，存储一组相同类型的元素，数组名在大多数情况下会被隐式转换为指向其第一个元素的指针，但数组的大小和位置在声明时确定且固定。

<h2 id="40.引用和指针的区别">40.引用和指针的区别</h2>
引用是一个变量的别名，在声明时必须初始化且不能改变引用对象，而指针是一个变量，存储另一个变量的地址，可以在任何时候改变指向不同的对象并支持算术操作。

<h2 id="41.什么是内联函数">41.什么是内联函数</h2>
内联函数是使用`inline`关键字修饰的函数，建议编译器在调用该函数时将其函数体展开以减少函数调用开销，适用于代码量小且频繁调用的函数，但编译器可能会根据实际情况选择是否真正内联。

<h2 id="39.指针与数组的区别">39.指针与数组的区别</h2>
宏函数使用`#define`预处理指令定义，在编译前进行文本替换，没有类型检查和作用域控制，易出错；自定义函数在编译时进行处理，支持类型检查、作用域控制和更好的调试，提供了更安全和灵活的功能定义方式。

<h2 id="40.引用和指针的区别">40.引用和指针的区别</h2>
函数调用的步骤包括将实参传递给形参，保存当前的执行状态（如返回地址），然后跳转到被调用函数的地址执行函数体代码，函数执行完毕后将返回值传递回调用者，恢复之前的执行状态并继续执行调用点之后的代码。

<h2 id="41.什么是内联函数">41.什么是内联函数</h2>
纯虚函数是未提供实现的虚函数，使用`= 0`语法声明，抽象类是包含至少一个纯虚函数的类，不能直接实例化，主要用于定义接口，由其派生类提供具体实现。

<h2 id="42.宏函数和自定义函数的区别">42.宏函数和自定义函数的区别</h2>
宏函数通过`#define`定义，进行简单的文本替换，没有类型检查和作用域控制，可能导致难以调试的错误；自定义函数则在编译时处理，支持类型检查和作用域控制，提供更安全和可靠的代码执行方式。

<h2 id="43.函数调用的步骤">43.函数调用的步骤</h2>
函数重载要求同一作用域内的多个函数具有相同的名称，但参数列表必须不同，包括参数的数量、类型或顺序，以便编译器能够区分并正确调用相应的函数版本。

<h2 id="44.什么是纯虚函数抽象类">44.什么是纯虚函数抽象类</h2>
构造函数是与类同名的特殊成员函数，在创建对象时自动调用，用于初始化对象的成员变量，不能有返回类型（包括void），可以重载以提供不同的初始化方式，并且可以有默认参数，但不能被显式调用或继承。

<h2 id="45.函数重载条件">45.函数重载条件</h2>
友元函数是被声明为某个类的友元的函数，允许它访问该类的私有和保护成员，尽管它本身并不是该类的成员，通常用于实现需要直接访问对象内部实现细节的功能，如重载运算符或实现外部辅助函数。

<h2 id="46.构造函数的特点？">46.构造函数的特点</h2>
构造函数的作用是初始化对象的成员变量，并执行任何必要的设置操作，在对象创建时自动调用，确保对象在使用前处于有效状态，并可以通过重载提供多种初始化方式。

<h2 id="47.什么是析构函数、析构函数的作用">47.什么是析构函数、析构函数的作用</h2>
析构函数是类的特殊成员函数，与类同名但前面带有波浪号`~`，在对象生命周期结束时自动调用，其作用是执行清理操作，如释放动态分配的内存、关闭文件或释放其他资源，确保对象在销毁前完成所有必要的清理工作。

<h2 id="48.C++定义常量两种方式是什么？">48.C++定义常量两种方式是什么？</h2>
    #define 宏常量： #define 常量名 常量值
    通常在文件上方定义，表示一个常量
    const修饰的变量 const 数据类型 常量名 = 常量值
    通常在变量定义前加关键字const，修饰该变量为常量，不可修改
    
<h2 id="49.重载函数是否能够通过函数返回值的类型不同来区分？">49.重载函数是否能够通过函数返回值的类型不同来区分？</h2>
不能。重载函数不能仅仅通过函数返回值类型的不同来区分。C++的函数重载是基于参数列表的不同（包括参数的数量、类型或顺序）来实现的，编译器无法仅根据返回类型来确定。

<h2 id="50.在C++程序中调用被C编译器编译后的函数，为什么要加extern“C”？">50.在C++ 程序中调用被C 编译器编译后的函数，为什么要加extern “C”？</h2>
首先，`extern` 是C/C++语言中用于指定函数和全局变量作用范围的关键字。它告诉编译器，这些声明的函数和变量可以在当前模块或其它模块中使用。

通常在模块的头文件中，对本模块提供给其它模块引用的函数和全局变量使用`extern`关键字进行声明。`extern "C"` 是一种连接声明(linkage declaration)，被 `extern "C"` 修饰的变量和函数按照C语言的方式进行编译和连接。作为面向对象的语言，C++支持函数重载，而过程式语言C则不支持。函数被C++编译后在符号库中的名字与C语言的不同。例如，假设某个函数的原型为：`void foo(int x, int y);` 该函数被C编译器编译后在符号库中的名字为 `_foo`，而C++编译器则会产生像 `_foo_int_int` 之类的名字。这样的名字包含了函数名、函数参数数量及类型信息，C++通过这种机制实现函数重载。

总结来说，`extern "C"` 声明的主要目的是解决名字匹配问题，从而实现C++与C的混合编程。

<h2 id="51.头文件中的ifndef/define/endif有什么作用？">51.头文件中的ifndef/define/endif有什么作用？</h2>
在C++头文件中，#ifndef、#define 和 #endif 的组合用于防止头文件被多次包含。这种机制称为“头文件保护”或“包含保护”。它的主要作用是避免重复定义导致的编译错误。下面是每个部分的详细作用：
    #ifndef（如果未定义）：
    这个指令用于检查一个特定的宏是否未被定义。如果未定义，则继续处理后续的代码。
    #define（定义）：
    这个指令用于定义一个宏。通过定义一个唯一的标识符，可以确保在其他地方包含同一个头文件时，这个标识符已经定义，从而避免重复包含。
    #endif（结束条件编译）：
    这个指令标志着条件编译的结束。如果前面的条件（即 #ifndef）为真，编译器会处理 #endif 之前的所有代码。
<h2 id="52.＃include<file.h>与＃include"file.h"的区别？">52.＃include<file.h>与＃include"file.h"的区别？</h2>
在C/C++中，#include <file.h> 和 #include "file.h" 都用于包含头文件，但它们有一些重要的区别：

    #include <file.h>：
        这种方式主要用于包含标准库头文件。
        编译器会在标准系统目录中查找指定的头文件。
        系统目录通常包括编译器默认的头文件路径以及在编译器配置中指定的路径。

    #include "file.h"：
        这种方式主要用于包含用户自定义的头文件。
        编译器首先在当前源文件所在的目录中查找指定的头文件。
        如果在当前目录中找不到，编译器会在标准系统目录中继续查找。
        可以用于包含项目中的其他模块或文件。

总体来说：
使用 #include "file.h" 可以确保编译器优先查找当前项目目录，这在开发过程中非常有用，尤其是当你有自定义的头文件时。
使用 #include <file.h> 可以避免与标准库头文件冲突，并且编译器在查找标准库头文件时通常会进行一些优化。

<h2 id="53.介绍一下C/C++各自的特点？">53.介绍一下C/C++各自的特点？</h2>
C语言是一种结构化语言，侧重于过程编程，基于算法和数据结构，关注的是如何通过过程或函数从输入得到输出。C++则是一种面向对象的语言，基于类、对象和继承，关注的是如何构建一个对象模型，使其能够与所处理的问题相适应，并通过获取对象的状态信息来实现输出或过程控制。


<h2 id="54.介绍一下const 用途？">54.介绍一下const 用途？</h2>

在C和C++中，`const` 关键字用于定义常量和限制变量的可修改性。它的主要用途如下：
1. **定义常量**：
   - 使用 `const` 关键字可以定义不可修改的变量，这样可以避免在程序中意外改变其值。
   ```cpp
   const int MAX_SIZE = 100;
   ```
2. **保护函数参数**：
   - 在函数参数中使用 `const` 可以防止在函数内部修改传入的参数值，确保参数在函数内部是只读的。
   ```cpp
   void printArray(const int* array, int size);
   ```
3. **修饰成员函数**：
   - 在C++中，`const` 可以用来修饰成员函数，表示该成员函数不会修改对象的状态。即，该成员函数不允许修改类的成员变量。
   ```cpp
   class MyClass {
   public:
       int getValue() const;
   private:
       int value;
   };
   ```
4. **指针和引用**：
   - `const` 可以用于修饰指针和引用，分别表示指针指向的内容不可变或指针本身不可变。
   ```cpp
   const int* ptr1;   // 指向常量的指针，指针指向的内容不可变
   int* const ptr2;   // 常量指针，指针本身不可变
   const int* const ptr3; // 指向常量的常量指针，指针本身和指针指向的内容都不可变
   ```
5. **常量引用**：
   - 在C++中，常量引用可以用于函数参数，避免拷贝大的对象，同时防止修改对象。
   ```cpp
   void display(const std::string& str);
   ```
### 示例代码
#### 定义常量
```cpp
const double PI = 3.14159;
```
#### 函数参数

```cpp
void displayArray(const int* arr, int size) {
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
}
```
#### 修饰成员函数

```cpp
class Circle {
public:
    Circle(double r) : radius(r) {}
    double getArea() const {
        return 3.14159 * radius * radius;
    }
private:
    double radius;
};
```
#### 指针和引用
```cpp
void example() {
    int value = 10;
    const int* ptr1 = &value;   // ptr1指向的内容不能被改变
    int* const ptr2 = &value;   // ptr2不能指向其他地址
    const int* const ptr3 = &value; // ptr3的指向和内容都不能被改变
}
```
通过使用 `const`，可以提高代码的安全性和可读性，防止意外修改数据，确保函数行为的一致性。

<h2 id="55.const和#define有什么区别？">55.const和#define有什么区别？</h2>
`const` 和 `#define` 在C和C++中都有定义常量的作用，但它们之间有一些重要的区别：

1. **类型检查**：
   - `const` 变量具有类型，编译器会进行类型检查，确保类型安全。
   - `#define` 定义的宏常量没有类型，编译器不进行类型检查，这可能会导致一些意想不到的错误。

2. **作用域**：
   - `const` 常量具有作用域，可以是局部的（如在函数内定义）或全局的（如在文件顶层定义），并且遵循C/C++的作用域规则。
   - `#define` 定义的宏常量没有作用域概念，它们在预处理阶段被简单地文本替换，作用于整个文件。

3. **存储方式**：
   - `const` 常量在内存中有实际的存储位置，可以取地址。
   - `#define` 定义的宏常量在编译后没有存储位置，只是简单的文本替换，不能取地址。

4. **调试支持**：
   - `const` 常量在调试时可以查看其值，因为它们在内存中有实际存储位置。
   - `#define` 宏常量在调试时难以查看，因为它们只是文本替换，没有实际存储位置。

5. **语法和使用**：
   - `const` 常量需要指定类型，并且遵循变量的声明和初始化规则。
   - `#define` 宏常量是预处理指令，不需要类型和分号，只需简单的文本替换。

### 示例

#### 使用 `const` 定义常量

```cpp
const int MAX_SIZE = 100;

void example() {
    const double PI = 3.14159;
    // MAX_SIZE 和 PI 都具有类型和作用域，可以进行类型检查和调试
}
```

#### 使用 `#define` 定义宏常量

```cpp
#define MAX_SIZE 100

void example() {
    #define PI 3.14159
    // MAX_SIZE 和 PI 都是简单的文本替换，没有类型检查和作用域
}
```

### 详细示例

#### 类型检查

```cpp
const int MAX_SIZE = 100;
float size = MAX_SIZE; // 类型安全，编译器会检查类型

#define MAX_SIZE 100
float size = MAX_SIZE; // 没有类型检查，编译器不会报错
```

#### 调试支持

```cpp
const int MAX_SIZE = 100;

#define MAX_SIZE 100

void example() {
    const int x = MAX_SIZE; // 可以在调试时查看 x 的值

    int y = MAX_SIZE; // 编译后，y = 100，没有实际存储位置，难以调试
}
```

#### 作用域

```cpp
void example() {
    const int local_const = 50; // 只在函数内有效
    #define LOCAL_MACRO 50 // 在整个文件内有效
}
```

#### 取地址

```cpp
const int MAX_SIZE = 100;
const int* ptr = &MAX_SIZE; // 可以取地址

#define MAX_SIZE 100
// int* ptr = &MAX_SIZE; // 错误，无法取地址
```

综上所述，`const` 提供了类型安全、作用域管理和调试支持，而 `#define` 则是简单的文本替换，适用于定义无需类型检查的常量。

<h2 id="55.sizeof与strlen的区别？">55.sizeof与strlen的区别？</h2>
`sizeof` 和 `strlen` 都用于获取数据大小，但它们有不同的用途和工作方式。下面是它们之间的区别：

### `sizeof` 操作符

1. **用途**：
   - 用于确定变量、数据类型或对象的大小（以字节为单位）。

2. **工作方式**：
   - 在编译时计算出其操作数的大小。

3. **适用对象**：
   - 可以用于基本数据类型、数组、结构体、类等。

4. **返回值类型**：
   - 返回的是 `size_t` 类型。

5. **示例**：
   ```cpp
   int a = 10;
   int arr[10];
   struct MyStruct {
       int x;
       double y;
   };

   size_t size_a = sizeof(a);          // 计算int类型变量a的大小，通常是4字节
   size_t size_arr = sizeof(arr);      // 计算数组arr的总大小，10 * sizeof(int)
   size_t size_struct = sizeof(MyStruct); // 计算结构体MyStruct的大小
   ```

### `strlen` 函数

1. **用途**：
   - 用于计算以 `null` 结尾的字符串的长度（不包括末尾的 `null` 字符）。

2. **工作方式**：
   - 在运行时遍历字符串直到找到 `null` 字符（`'\0'`），计算其长度。

3. **适用对象**：
   - 仅用于以 `null` 结尾的字符数组或字符串常量。

4. **返回值类型**：
   - 返回的是 `size_t` 类型。

5. **示例**：
   ```cpp
   const char* str = "Hello, world!";
   size_t length = strlen(str);  // 计算字符串的长度，不包括末尾的'\0'，结果是13
   ```

### 详细示例

#### 使用 `sizeof` 计算类型和数组大小

```cpp
#include <iostream>

int main() {
    int num = 42;
    int arr[10];
    char str[] = "Hello";

    std::cout << "Size of int: " << sizeof(int) << std::endl;       // 4（通常）
    std::cout << "Size of num: " << sizeof(num) << std::endl;       // 4（通常）
    std::cout << "Size of arr: " << sizeof(arr) << std::endl;       // 40（10 * 4）
    std::cout << "Size of str: " << sizeof(str) << std::endl;       // 6（包括'\0'）
    
    return 0;
}
```

#### 使用 `strlen` 计算字符串长度

```cpp
#include <iostream>
#include <cstring>

int main() {
    const char* str1 = "Hello, world!";
    char str2[] = "Hello";

    std::cout << "Length of str1: " << strlen(str1) << std::endl;   // 13
    std::cout << "Length of str2: " << strlen(str2) << std::endl;   // 5
    
    return 0;
}
```

### 总结

- `sizeof` 用于计算变量、类型或对象的大小，在编译时确定，适用于任何类型。
- `strlen` 用于计算以 `null` 结尾的字符串长度，在运行时确定，只适用于以 `null` 结尾的字符数组或字符串常量。

<h2 id="56.什么是多态？多态有什么作用？">56.什么是多态？多态有什么作用？</h2>
多态是C++中的一种面向对象编程特性，它允许通过基类指针或引用调用派生类中的重写函数，实现同一操作在不同对象上的不同表现。多态的作用在于提高代码的灵活性和可扩展性，使得程序能够处理不同类型的对象而不需要知道它们的具体类型，从而实现更好的代码复用和系统扩展。
<h2 id="57.重载和覆盖有什么区别？">57.重载和覆盖有什么区别？</h2>
重载（Overloading）和覆盖（Overriding）是C++中的两种多态机制。重载指的是在同一个作用域内定义多个同名函数，但参数列表不同（参数类型、数量或顺序），以支持不同的函数调用；而覆盖指的是在派生类中重新定义基类中已经存在的虚函数，通过匹配函数签名和使用虚函数机制，改变或扩展基类函数的行为。重载是在编译时选择适当的函数，覆盖是在运行时决定调用哪个函数。

<h2 id="58.空指针和悬垂指针的区别？">58.空指针和悬垂指针的区别？</h2>
空指针和悬垂指针在C/C++中分别代表不同的指针问题：

- **空指针（NULL Pointer）**：是一个指向无效或未分配内存的指针，通常用于表示指针当前不指向任何有效对象。空指针的值是 `NULL`（在C++中通常使用 `nullptr`）。空指针的主要用途是作为初始化值或检查指针是否有效的标志。

  ```cpp
  int* ptr = nullptr; // 空指针
  ```

- **悬垂指针（Dangling Pointer）**：是一个指向已经被释放或不再有效的内存区域的指针。这种指针指向的内存区域可能已经被重新分配或销毁，使用悬垂指针会导致未定义行为或程序崩溃。悬垂指针通常是由于内存释放后没有将指针设置为 `NULL` 或 `nullptr` 造成的。

  ```cpp
  int* ptr = new int(10); // 动态分配内存
  delete ptr;             // 释放内存
  // ptr 现在是悬垂指针
  ```

总结：空指针表示指针当前不指向任何有效对象，而悬垂指针指向已经无效的内存区域，前者用于初始化和检查，后者则可能导致严重的程序错误。

<h2 id="59.什么是智能指针，它的作用有哪些，智能指针有什么缺点？">59.什么是智能指针，它的作用有哪些，智能指针有什么缺点？</h2>

智能指针是一种在C++中用于自动管理动态分配的内存生命周期的类模板。它们通过提供类似指针的接口，并在适当的时候自动释放所管理的内存，帮助避免内存泄漏和指针错误。
C++标准库中常用的智能指针有：
std::unique_ptr：独占所有权模型，不可复制但可以移动。它保证同一时间只有一个智能指针拥有对某块内存的控制。
std::shared_ptr：共享所有权模型，可以被复制，并通过引用计数来管理内存。当没有任何shared_ptr指向一块内存时，该块内存会被自动释放。
std::weak_ptr：伴随shared_ptr的非拥有型智能指针，用来解决shared_ptr相互引用时可能产生的循环依赖问题。不增加引用计数，因此不影响其指向的对象的生命周期。
智能指针缺点：
性能开销：智能指针（尤其是std::shared_ptr）通过引用计数来管理内存，这会增加额外的性能开销，比原始指针慢。
循环引用问题：std::shared_ptr在存在循环引用时会导致内存泄漏，因为引用计数永远不会达到0，除非使用std::weak_ptr打破循环。
复杂性增加：虽然智能指针有助于内存管理，但不当使用可以增加程序复杂性，误用可能导致难以调试的问题，如悬挂指针或者提前释放等。
不适用场景：特定场景下（如高性能或者低延迟要求的应用），智能指针所带来的额外开销可能是不可接受的。


<h2 id="60.C++空类默认有哪些成员函数？">60.C++空类默认有哪些成员函数？</h2>
在C++中，即使一个类没有显式定义任何成员函数，编译器也会自动生成默认的构造函数、析构函数、复制构造函数和赋值运算符。这些默认成员函数使得空类可以被创建、销毁，并支持对象的复制和赋值操作。例如，空类 `class Empty {};` 会自动获得这些默认成员函数的实现，除非你显式地定义或删除它们。

<h2 id="61.C++哪一种成员变量可以在一个类的实例之间共享？">61.C++哪一种成员变量可以在一个类的实例之间共享？</h2>
在C++中，`static` 成员变量可以在一个类的所有实例之间共享。`static` 成员变量属于类本身，而不是某个特定的对象，因此所有类的实例共享同一个 `static` 成员变量的值。

### 特点
- **共享**：所有对象实例共享同一个 `static` 成员变量。
- **类作用域**：它的生命周期与类的生命周期相同，而不是与对象的生命周期相同。
- **访问**：可以通过类名直接访问，也可以通过对象实例访问，但通常通过类名来访问更为明确。

### 示例代码

```cpp
#include <iostream>

class MyClass {
public:
    static int sharedValue; // 静态成员变量声明
    void printValue() const {
        std::cout << "Shared value: " << sharedValue << std::endl;
    }
};

// 静态成员变量的定义
int MyClass::sharedValue = 0;

int main() {
    MyClass obj1;
    MyClass obj2;

    obj1.sharedValue = 10; // 修改静态成员变量

    obj1.printValue(); // 输出: Shared value: 10
    obj2.printValue(); // 输出: Shared value: 10

    return 0;
}
```

在这个示例中，`sharedValue` 是一个静态成员变量，它的值在所有 `MyClass` 类的实例之间共享。无论通过哪个实例访问或修改 `sharedValue`，所有实例都会看到相同的值。

<h2 id="62.继承层次中，为什么基类析构函数是虚函数？">62.继承层次中，为什么基类析构函数是虚函数？</h2>
在继承层次中，基类的析构函数应该是虚函数，以确保在通过基类指针删除派生类对象时，能够正确调用派生类的析构函数，从而避免资源泄漏和未定义行为。虚析构函数使得 C++ 的动态绑定机制能够在删除对象时正确地调用实际的派生类析构函数，从而完成派生类特有资源的释放。



<h2 id="63.面向对象技术的基本概念是什么，三个基本特征是什么？">63.面向对象技术的基本概念是什么，三个基本特征是什么？</h2>
基本概念：类、对象、继承； 基本特征：封装、继承、多态。
封装：将低层次的元素组合起来形成新的、更高实体的技术；
继承：广义的继承有三种实现形式：实现继承、可视继承、接口继承。
多态：允许将子类类型的指针赋值给父类类型的指针


<h2 id="64.为什么构造函数不能为虚函数？">64.为什么构造函数不能为虚函数？</h2>
虚函数采用一种虚调用的方法。需调用是一种可以在只有部分信息的情况下工作的机制。如果创建一个对象，则需要知道对象的准确类型，因此构造函数不能为虚函数。


<h2 id="65.虚函数是什么？为什么不把所有函数设为虚函数？">65.虚函数是什么？为什么不把所有函数设为虚函数？</h2>
不行。首先，虚函数是有代价的，由于每个虚函数的对象都要维护一个虚函数表，因此在使用虚函数的时候都会产生一定的系统开销，这是没有必要的。



<h2 id="66.什么是多态？多态有什么作用？">66.什么是多态？多态有什么作用？</h2>
多态就是将基类类型的指针或者引用指向派生类型的对象。多态通过虚函数机制实现。多态的作用是接口重用。

<h2 id="67.什么是公有继承、受保护继承、私有继承？">67.什么是公有继承、受保护继承、私有继承？</h2>
多态就是将基类类型的指针或者引用指向派生类型的对象。多态通过虚函数机制实现。多态的作用是接口重用。

（1）公有继承时，派生类对象可以访问基类中的公有成员，派生类的成员函数可以访问基类中的公有和受保护成员；
（2）私有继承时，基类的成员只能被直接派生类的成员访问，无法再往下继承；
（3）受保护继承时，基类的成员也只被直接派生类的成员访问，无法再往下继承。



<h2 id="68.什么是虚指针？">68.什么是虚指针？</h2>
虚指针或虚函数指针是虚函数的实现细节。带有虚函数的每一个对象都有一个虚指针指向该类的虚函数表。

<h2 id="69.C++如何阻止一个类被实例化？">69.C++如何阻止一个类被实例化？</h2>
（1）将类定义为抽象基类或者将构造函数声明为private；
（2）不允许类外部创建类对象，只能在类内部创建对象


<h2 id="70.main函数执行之前会执行什么？执行之后还能执行代码吗？">70.main函数执行之前会执行什么？执行之后还能执行代码吗？</h2>
（1）全局对象的构造函数会在main函数之前执行；
（2）可以，可以用_onexit 注册一个函数，它会在main 之后执行;

如果你需要加入一段在main退出后执行的代码，可以使用atexit()函数，注册一个函数。

<h2 id="71.进程和线程的区别是什么？">71.进程和线程的区别是什么？</h2>
（1）进程是程序的一次执行，线程是进程中的执行单元；
（2）进程间是独立的，这表现在内存空间、上下文环境上，线程运行在进程中；
（3）一般来讲，进程无法突破进程边界存取其他进程内的存储空间；而同一进程所产生的线程共享内存空间；
（4）同一进程中的两段代码不能同时执行，除非引入多线程。
总的来说进程是操作系统分配资源和调度的独立单位，拥有自己的地址空间和系统资源。线程是进程内部的执行单元，共享属于相同进程的资源，但是执行切换代价更小。进程间相互独立，稳定性较高；线程间共享内存，创建和切换成本较低，但一个线程的失败可能影响同进程的其他线程。
<h2 id="72.进程间如何通信？">72.进程间如何通信？</h2>
管道：允许一个进程和另一个与它有共同祖先的进程之间进行通信。
消息队列：消息的链表，存储在内核中，由进程间发送接收消息。
共享内存：允许多个进程访问同一块内存空间，是最快的IPC方式。
信号量：主要用于解决进程间的同步问题。
套接字：适用于不同机器间的进程通信。
信号：用于通知接收进程某个事件已经发生。

<h2 id="73.在网络编程中涉及并发服务器，使用多进程与多线程的区别？">73.在网络编程中涉及并发服务器，使用多进程与多线程的区别？</h2>
（1）线程执行开销小，但不利于资源管理和保护；进程则相反，进程可跨越机器迁移。
（2）多进程时每个进程都有自己的内存空间，而多线程间共享内存空间；
（3）线程产生的速度快，线程间通信快、切换快；
（4）线程的资源利用率比较好；
（5）线程使用公共变量或者资源时需要同步机制。

<h2 id="74.C++中经常要操作的内存分为那几个类别？">74.经常要操作的内存分为那几个类别？</h2>
（1）栈区：由编译器自动分配和释放，存放函数的参数值、局部变量的值等；
（2）堆：一般由程序员分配和释放，存放动态分配的变量（使用new和delete管理）；
（3）全局区（静态区）：全局变量和静态变量存放在这一块，初始化的和未初始化的分开放；
（4）文字常量区：常量字符串就放在这里，程序结束自动释放；
（5）程序代码区：参访函数体的二进制代码。

<h2 id="75.堆和栈的区别有什么？">75.请讲述堆和栈的区别？</h2>
（1）申请方式不同。栈上有系统自动分配和释放；堆上有程序员自己申请并指明大小；
（2）栈是向低地址扩展的数据结构，大小很有限；堆是向高地址扩展，是不连续的内存区域，空间相对大且灵活；
（3）栈由系统分配和释放速度快；堆由程序员控制，一般较慢，且容易产生碎片；

<h2 id="76.类使用static成员的优点，如何访问？">76.类使用static成员的优点，如何访问？</h2>
优点：
（1）static 成员的名字是在类的作用域中，因此可以避免与其他类的成员或全局对象名字冲突；
（2）可以实施封装。static 成员可以是私有成员，而全局对象不可以；
（3） static 成员是与特定类关联的，可清晰地显示程序员的意图。
static 数据成员必须在类定义体的外部定义(正好一次)，static 关键字只能用于类定义体内部的声明中，定义不能标示为static. 不像普通数据成员，static成员不是通过类构造函数进行初始化，也不能在类的声明中初始化，而是应该在定义时进行初始化.保证对象正好定义一次的最好办法，就是将static 数据成员的定义放在包含类非内联成员函数定义的文件中。


<h2 id="77.介绍一下static数据成员和static成员函数？">77.介绍一下static数据成员和static成员函数？</h2>
（1）static数据成员：
static数据成员独立于该类的任意对象而存在；每个static数据成员是与类关联的对象，并不与该类的对象相关联。Static数据成员（const
static数据成员除外）必须在类定义体的外部定义。不像普通数据成员，static成员不是通过类的构造函数进行初始化，而是应该在定义时进行初始化。
（2）static成员函数：
Static成员函数没有this形参，它可以直接访问所属类的static成员，不能直接使用非static成员。因为static成员不是任何对象的组成部分，所以static成员不能被声明为const。同时，static成员函数也不能被声明为虚函数。

<h2 id="78.如何引用一个已经定义过的全局变量？">78.如何引用一个已经定义过的全局变量？</h2>
可以用引用头文件的方式，也可以用extern关键字，如果用引用头文件方式来引用某个在头文件中声明的全局变量，假定你将那个变量写错了，那么在编译期间会报错，如果你用extern方式引用时，假定你犯了同样的错误，那么在编译期间不会报错，而在连接期间报错。

<h2 id="79.介绍一下static关键字的作用。">79.介绍一下static关键字的作用</h2>
static总是使得变量或对象的存储形式变成静态存储，连接方式变成内部连接，对于局部变量（已经是内部连接了），它仅改变其存储方式；对于全局变量（已经是静态存储了），它仅改变其连接类型。


<h2 id="80.一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual,也能实现多态?在子类的空间里，有没有父类的这个函数，或者父类的私有变量?">80.一个父类写了一个virtual函数，如果子类覆盖它的函数不加virtual,也能实现多态?在子类的空间里，有没有父类的这个函数，或者父类的私有变量?</h2>
只要基类在定义成员函数时已经声明了 virtue关键字，在派生类实现的时候覆盖该函数时，virtue关键字可加可不加，不影响多态的实现。子类的空间里有父类的所有变量(static除外)。

<h2 id="81.完成字符串拷贝可以使用 sprintf、strcpy 及 memcpy 函数，请问这些函数有什么区别。">81.完成字符串拷贝可以使用sprintfstrcpy及memcpy 函数，请问这些函数有什么区别。</h2>
这些函数的区别在于 实现功能以及操作对象不同。
（1）strcpy 函数操作的对象是字符串，完成从源字符串到目的字符串的拷贝功能。
（2）sprintf 函数操作的对象不限于字符串：虽然目的对象是字符串，但是源对象可以是字符串、也可以是任意基本类型的数据。这个函数主要用来实现（字符串或基本数据类型）向字符串的转换功能。如果源对象是字符串，并且指定 %s 格式符，也可实现字符串拷贝功能。
（3）memcpy 函数顾名思义就是内存拷贝，实现将一个内存块的内容复制到另一个内存块这一功能。内存块由其首地址以及长度确定。程序中出现的实体对象，不论是什么类型，其最终表现就是在内存中占据一席之地（一个内存区间或块）。因此，memcpy
的操作对象不局限于某一类数据类型，或者说可适用于任意数据类型，只要能给出对象的起始地址和内存长度信息、并且对象具有可操作性即可。鉴于memcpy 函数等长拷贝的特点以及数据类型代表的物理意义，memcpy 函数通常限于同种类型数据或对象之间的拷贝，其中当然也包括字符串拷贝以及基本数据类型的拷贝。
对于字符串拷贝来说，用上述三个函数都可以实现，但是其实现的效率和使用的方便程度不同：
• strcpy 无疑是最合适的选择：效率高且调用方便。
• sprintf 要额外指定格式符并且进行格式转化，麻烦且效率不高。
• memcpy 虽然高效，但是需要额外提供拷贝的内存长度这一参数，易错且使用不便；并且如果长度指定过大的话（最优长度是源字符串长度 + 1），还会带来性能的下降。其实 strcpy 函数一般是在内部调用 memcpy 函数或者用汇编直接实现的，以达到高效的目的。因此，使用 memcpy 和 strcpy 拷贝字符串在性能上应该没有什么大的差别。
对于非字符串类型的数据的复制来说，strcpy 和 snprintf 一般就无能为力了，可是对 memcpy 却没有什么影响。但是，对于基本数据类型来说，尽管可以用 memcpy 进行拷贝，由于有赋值运算符可以方便且高效地进行同种或兼容类型的数据之间的拷贝，所以这种情况下 memcpy 几乎不被使用 。memcpy 的长处是用来实现（通常是内部实现居多）对结构或者数组的拷贝，其目的是或者高效，或者使用方便，甚或两者兼有。


<h2 id="82.应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？">82.应用程序在运行时的内存包括代码区和数据区，其中数据区又包括哪些部分？</h2>
对于一个进程的内存空间而言，可以在逻辑上分成 3个部份：代码区，静态数据区和动态数据区。
态数据区一般就是“堆栈”。 栈是一种线性结构，堆是一种链式结构。进程的每个线程都有私有的“栈”。
全局变量和静态变量分配在静态数据区，本地变量分配在动态数据区，即堆栈中。程序通过堆栈的基地址和偏移量来访问本地变量。

<h2 id="83.C++函数中值的传递方式有哪几种？">83.C++函数中值的传递方式有哪几种？</h2>
答：三种传递方式为：值传递、指针传递和引用传递。

<h2 id="84.C++里面是不是所有的动作都是main()引起的？">84.C++里面是不是所有的动作都是main()引起的？</h2>
比如全局变量的初始化，就不是由main函数引起的

<h2 id="85.内联函数在编译时是否做参数类型检查？">85.内联函数在编译时是否做参数类型检查？</h2>
内联函数要做参数类型检查, 这是内联函数跟宏相比的优势。

<h2 id="86.全局变量和局部变量有什么区别？怎么实现的？操作系统和编译器是怎么知道的？">86.全局变量和局部变量有什么区别？怎么实现的？操作系统和编译器是怎么知道的？</h2>
（1）生命周期不同：全局变量随主程序创建和创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至局部循环体等内部存在，退出就不存在。 
（2）使用方式不同：通过声明后全局变量程序的各个部分都可以用到；局部变量只能在局部使用，分配在栈区。
（3）操作系统和编译器通过内存分配的位置来知道的，全局变量分配在全局数据段并且在程序开始运行的时候被加载。局部变量则分配在堆栈里面 。

<h2 id="87.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？">87.static全局变量与普通的全局变量有什么区别？static局部变量和普通局部变量有什么区别？static函数与普通函数有什么区别？</h2>
static全局变量与普通全局变量区别：static全局变量只初使化一次，防止在其他文件单元中被引用;
static局部变量和普通局部变量区别：static局部变量只被初始化一次，下一次依据上一次结果值；
static函数与普通函数区别：static函数在内存中只有一份，普通函数在每个被调用中维持一份拷贝。

<h2 id="88.程序的局部变量、全局变量、以及动态申请的数据分别存储在哪里？">88.程序的局部变量、全局变量、以及动态申请的数据分别存储在哪里？</h2>
程序的局部变量存在于（堆栈）中，全局变量存在于（静态区 ）中，动态申请数据存在于（ 堆）中。


<h2 id="89.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?">89.对于一个频繁使用的短小函数,在C语言中应用什么实现,在C++中应用什么实现?</h2>
c用宏定义，c++用inline


<h2 id="90.共享内存安全吗，有什么措施保证?">90.共享内存安全吗，有什么措施保证?</h2>
共享内存本身没有内建安全措施，通过以下方式确保安全性：
使用互斥锁或信号量来同步对共享内存的访问。
实施访问控制，限制哪些进程可以访问共享内存。
定期检查和清理，避免僵尸进程造成的资源泄露。
根据需求实现读写锁，允许多读单写的安全访问模式。



<h2 id="91.多态实现方式是什么？">91.多态实现方式是什么？</h2>
多态在C++中的实现方式通常有两种：
虚函数（通过类的继承和虚函数表实现）
函数重载（同一作用域内多个同名函数通过参数列表区分）

<h2 id="92.介绍一下c++内存泄漏？">92.介绍一下c++内存泄漏？</h2>
C++中内存泄漏是指程序分配的内存未被释放且无法再次被访问，常见原因包括：

动态分配的内存（使用new或malloc）没有使用delete或free释放。
使用指针指向新的内存区域，而忘记释放原有内存。
数据结构中的循环引用导致无法自动释放。
避免内存泄漏的方法包括：

使用智能指针（如std::unique_ptr和std::shared_ptr）自动管理内存。
适时使用delete或free释放不再需要的动态分配内存。
定期使用内存检测工具（如Valgrind）检测和定位内存泄漏问题。

<h2 id="93.C++11的新特性都有哪些？">92. C++11 的新特性都有哪些？</h2>
自动类型推断(auto)。
范围for循环。
Lambda表达式和函数闭包。
右值引用和移动语义。
可变参数模板。
初始化列表。
强类型枚举。
智能指针如std::unique_ptr和std::shared_ptr。
空指针关键字(nullptr)。
线程库支持。
新容器如std::array和std::unordered_map。

<h2 id="94.介绍一下左值和右值引用">94.介绍一下左值和右值引用</h2>
左值引用是对可寻址的、可重复使用的对象（左值）的引用。它使用传统的单个&符号。右值引用是对临时对象（右值）的引用，使用双&&符号。右值引用允许实现移动语义和完美转发，它可以将资源从一个（临时的）对象转移到另一个对象，提高效率，避免不必要的复制。


<h2 id="95.介绍一下C++转型操作符？">95.介绍一下C++转型操作符？</h2>
static_cast：用于基本数据类型转换，以及向上转型（将派生类对象或指针转换为基类表示）。
dynamic_cast：用于类的层次结构中的安全向下转型和运行时类型检查，需要运行时RTTI（Run-Time Type Information）支持。
const_cast：用于移除对象的const或volatile属性。
reinterpret_cast：用于低级转换，重新解释底层位模式，可以将一个指针转换为任何其他类型的指针。

<h2 id="96. map和unordered_map了解吗？">96.map和unordered_map了解吗？</h2>
map：
底层实现是红黑树，一个自平衡的二叉搜索树。
元素根据键值自动排序。
插入、删除和查找操作的时间复杂度为O(log n)。

unordered_map：
底层实现是哈希表。
元素不会自动排序。
平均情况下插入、删除和查找操作的时间复杂度为O(1)，最坏情况下为O(n)。
<h2 id="97. vector的底层原理和扩容机制是什么？">97.vector的底层原理和扩容机制是什么？</h2>
底层原理:
vector是基于动态数组实现的，支持随机访问。
在连续的内存空间中存储元素，允许快速访问。

扩容机制:
当向vector添加元素超过其当前容量时，它会创建一个更大的动态数组，并将所有现有元素复制到新数组中，释放旧数组的内存。
新容量通常是当前容量的两倍，不过这可能因实现而异。
<h2 id="98. map的底层原理是什么？">98.map的底层原理是什么？</h2>

map的底层原理:
map的底层是基于红黑树实现的。
红黑树是一种自平衡二叉搜索树，它能保证基本操作（如查找、插入、删除）的时间复杂度为O(log n)，确保树的高度保持在对数级别。
通过键值对自动排序和高效操作维持了其数据结构的稳定性和效率。

<h2 id="99. socket与其他通信方式有什么不同？">99.socket与其他通信方式有什么不同？</h2>

Socket 可以实现不同主机间的进程通信，适用于网络中跨操作系统通信。
Socket 通常支持全双工通信，即同一时间可以进行数据的双向传输。
Socket 支持面向连接（如TCP协议）和无连接（如UDP协议）的通信方式。
使用 Socket 进行通信需要创建、配置、使用和关闭套接字，比其他通信方式如管道和信号等有更明确的使用流程。

<h2 id="100.TCP和UDP的区别是什么，TCP什么时候会重传？">100.TCP和UDP的区别是什么，TCP什么时候会重传？</h2>

连接：
TCP是面向连接的协议，进行数据传输前需要建立连接。
UDP是无连接的协议，不需要建立连接就可以直接发送数据。
可靠性：
TCP提供可靠的数据传输，确保数据完整性和顺序。
UDP提供不可靠的数据传输，可能出现丢包，不保证数据顺序。
速度：
TCP相对较慢，因为它需要确认机制和错误校正。
UDP传输速度更快，没有确认机制，适用于对速度要求高的场合。
数据流：
TCP提供字节流服务，通过数据流的方式发送数据。
UDP以数据报文的形式发送信息，发送独立的消息。

超时重传：如果发送方在设定的超时时间内没有收到接收方的确认（ACK），它会重传那个数据段。 快速重传：如果发送方收到三个或更多的冗余ACK（即对同一个数据段的连续确认），它会在没有等待超时的情况下立即重传那个被认为丢失的数据段。 接收方提示：接收方可以通过ACK中的SACK选项（选择确认），明确指出哪些数据段已收到，哪些未收到，促使发送方仅重传未被确认接收的数据段。
